#include "stdafx.h"
#include "AdoHelper1.h"

#ifdef _DEBUG
#define DelLogDebugEvent(a, b, c, d, e, f) {char sErr[1024];sprintf_s(sErr,1024,"\n%s(%d):%s %s %s\n",e,f,a,b,c);OutputDebugString(sErr);}
#else
#define DelLogDebugEvent(a, b, c, d, e, f) TRACE("\n%s(%d):%s\n",__FILE__,__LINE__,(c));
#endif // _DEBUG

using namespace _com_util;

CADODatabase::CADODatabase()
{
	m_pConnection	= NULL;
	m_strConnection = _T("");	
	::CoInitialize(NULL);
}

CADODatabase::~CADODatabase()
{
	Close();
	m_pConnection.Release();
	m_pConnection = NULL;
	::CoUninitialize();
}

DWORD CADODatabase::GetRecordCount(_RecordsetPtr m_pRs)
{
	DWORD numRows = 0;

	numRows = m_pRs->GetRecordCount();

	if(numRows == -1)
	{
		if(m_pRs->EndOfFile != VARIANT_TRUE)
			m_pRs->MoveFirst();

		while(m_pRs->EndOfFile != VARIANT_TRUE)
		{
			numRows++;
			m_pRs->MoveNext();
		}
		if(numRows > 0)
			m_pRs->MoveFirst();
	}
	return numRows;
}

bool CADODatabase::Open(LPCTSTR lpstrConnection, LPCTSTR lpstrUserID, LPCTSTR lpstrPassword)
{
	HRESULT hr = S_OK;

	if (m_pConnection == NULL)
	{
		try
		{
			hr = m_pConnection.CreateInstance(__uuidof(Connection));
			//hr = m_pConnection.CreateInstance("ADODB.Connection"/* __uuidof( Connection )*/ );
			if (SUCCEEDED(hr))
			{
			}
			else if(FAILED(hr))
			{
			}
		}
		catch( _com_error &e )
		{
			// Get info from _com_error
			_bstr_t bstrSource(e.Source());
			_bstr_t bstrDescription(e.Description());
			TRACE( "Exception thrown for classes generated by #import" );
			TRACE( "\tCode = %08lx\n", e.Error());
			TRACE( "\tCode meaning = %s\n", e.ErrorMessage());
			TRACE( "\tSource = %s\n", (LPCTSTR) bstrSource);
			TRACE( "\tDescription = %s\n", (LPCTSTR) bstrDescription);
		}
		catch(...)
		{
			TRACE( "*** Unhandled Exception ***" );
		} 
	}

	if(IsOpen())
		Close();

	if(strcmp(lpstrConnection, _T("")) != 0)
		m_strConnection = lpstrConnection;

	if (m_strConnection.IsEmpty())
	{
		CString strEvent;
		strEvent.Format("- Input connection string is empty.\n");
		DelLogDebugEvent("CADODatabase", "Open", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}

	try
	{
		hr = m_pConnection->Open(_bstr_t(m_strConnection), _bstr_t(lpstrUserID), _bstr_t(lpstrPassword), NULL);
		//hr = m_pConnection->Open(_bstr_t(m_strConnection), "", "", NULL);
		return hr == S_OK;
	}
	catch(_com_error &e)
	{
		dump_com_error(e);
	}
	return false;
}

void CADODatabase::dump_com_error(_com_error &e)
{
	CString ErrorStr;
	_bstr_t bstrSource(e.Source());
	_bstr_t bstrDescription(e.Description());
	ErrorStr.Format( "CADODataBase Error\n\tCode = %08lx\n\tCode meaning = %s\n\tSource = %s\n\tDescription = %s\n",
		e.Error(), e.ErrorMessage(), (LPCSTR)bstrSource, (LPCSTR)bstrDescription );
	m_strLastError = _T("Connection String = " + GetConnectionString() + '\n' + ErrorStr);

	//	#ifdef _DEBUG
	//		AfxMessageBox( ErrorStr, MB_OK | MB_ICONERROR );
	//	#endif	

	TRACE("%s",COleDateTime::GetCurrentTime().Format("%Y-%m-%d %H:%M:%S"));
	//	ASSERT(FALSE);
	DelLogDebugEvent("CADODatabase", "dump_com_error", ErrorStr, eDELIMPORTANCE_LEVEL_HIGH, __FILE__, __LINE__);
}

bool CADODatabase::IsOpen()
{
	if(m_pConnection )
		return m_pConnection->GetState() != adStateClosed;
	return false;
}

void CADODatabase::Close()
{
	if(IsOpen())
		m_pConnection->Close();
}

CADORecordset::CADORecordset(CADODatabase* pAdoDatabase)
{
	m_pRecordset = NULL;
	m_pCmd = NULL;
	m_strQuery = _T("");
	m_pRecordset.CreateInstance(__uuidof(Recordset));
	m_pCmd.CreateInstance(__uuidof(Command));

	m_nEditStatus		= CADORecordset::dbEditNone;
	m_nSearchDirection	= CADORecordset::searchForward;
	m_nCursorLocation	= CADORecordset::useNone;
	m_nCursorType		= CADORecordset::cursorUnspecified;
	m_nLockType			= CADORecordset::lockUnspecified;

	m_pConnection = pAdoDatabase->GetActiveConnection();
}

bool CADORecordset::Open(_ConnectionPtr mpdb, LPCTSTR lpstrExec, int nOption)
{	
	Close();

	if(strcmp(lpstrExec, _T("")) != 0)
		m_strQuery = lpstrExec;

	m_strQuery.TrimLeft();

	if (m_strQuery.IsEmpty())
	{
		CString strEvent;
		strEvent.Format("- Input query string is empty.\n");
		DelLogDebugEvent("CADORecordset", "Open", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}

	BOOL bIsSelect = m_strQuery.Mid(0, (int)strlen("Select ")).CompareNoCase("select ") == 0;

	try
	{
		// Cursor Location
		if(m_nCursorLocation == useNone)
		{
			if (nOption == openStoredProc)
				m_nCursorLocation = useServer;
			else
				m_nCursorLocation = useClient;
		}
		// Cursor Type
		if(m_nCursorType == cursorUnspecified)
		{
			if (nOption == openQuery)
				m_nCursorType = cursorStatic;
			else if (nOption == openStoredProc)
				m_nCursorType = cursorForwardOnly;
			else
				m_nCursorType = cursorDynamic; // default to dynamic
		}
		// Lock Type
		if(m_nLockType == lockUnspecified)
		{
			if (nOption == openStoredProc)
				m_nLockType = lockReadOnly;
			else
				m_nLockType = lockOptimistic;
		}
		m_pRecordset->CursorLocation = (enum CursorLocationEnum)m_nCursorLocation;

		if(bIsSelect || nOption == openQuery)
		{
			m_pRecordset->Open((LPCSTR)m_strQuery, _variant_t((IDispatch*)mpdb, true), 
				(enum ADOCG::CursorTypeEnum)m_nCursorType, 
				(enum ADOCG::LockTypeEnum)m_nLockType,
				adCmdUnknown);
		}
		else if(nOption == openTable)
		{
			m_pRecordset->Open((LPCSTR)m_strQuery, _variant_t((IDispatch*)mpdb, true), 
				(enum ADOCG::CursorTypeEnum)m_nCursorType,
				(enum ADOCG::LockTypeEnum)m_nLockType,
				adCmdTable);
		}
		else if(nOption == openStoredProc)
		{
			m_pRecordset->Open((LPCSTR)m_strQuery, _variant_t((IDispatch*)mpdb, true),
				(enum ADOCG::CursorTypeEnum)m_nCursorType,
				(enum ADOCG::LockTypeEnum)m_nLockType,
				adCmdText);
		}
		else
		{
			CString strEvent;
			strEvent.Format("- Invalid option to open a recordset (%d).\n", nOption);
			DelLogDebugEvent("CADORecordset", "Open", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
			return false;
		}
	}
	catch(_com_error &e)
	{
		dump_com_error(e);
		return false;
	}

	return m_pRecordset != NULL;
}

bool CADORecordset::Open(LPCTSTR lpstrExec, int nOption)
{
	if (m_pConnection == NULL)
	{
		CString strEvent;
		strEvent.Format("- Connection is NULL.\n");
		DelLogDebugEvent("CADORecordset", "Open", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}

	return Open(m_pConnection, lpstrExec, nOption);
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, double& dbValue)
{	
	double val = (double)NULL;
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	if(vtFld.vt != VT_NULL)
		val = vtFld.dblVal;
	dbValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, double& dbValue)
{	
	double val = (double)NULL;
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	if(vtFld.vt != VT_NULL)
		val = vtFld.dblVal;
	dbValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, long& lValue)
{
	long val = (long)NULL;
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	if(vtFld.vt != VT_NULL)
		val = vtFld.lVal;
	lValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, long& lValue)
{
	long val = (long)NULL;
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;
	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	if(vtFld.vt != VT_NULL)
		val = vtFld.lVal;
	lValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, BYTE& byValue)
{
	long lTemp;
	GetFieldValue(lpFieldName, lTemp);
	byValue = (BYTE)lTemp;
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, BYTE& byValue)
{
	long lTemp;
	GetFieldValue(nIndex, lTemp);
	byValue = (BYTE)lTemp;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, int& nValue)
{
	int val = NULL;
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	switch(vtFld.vt)
	{
	case VT_I2:
		val = vtFld.iVal;
		break;
	case VT_BOOL:
		val = vtFld.boolVal;
	case VT_NULL:
	case VT_EMPTY:
		break;
	default:
		nValue = 0;
		return false;
	}	
	nValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, int& nValue)
{
	int val = (int)NULL;
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;
	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	switch(vtFld.vt)
	{
	case VT_I2:
		val = vtFld.iVal;
		break;
	case VT_NULL:
	case VT_EMPTY:
		val = 0;
		break;
	default:
		return false;
	}	
	nValue = val;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, CString& strValue)
{
	CString str = _T("");
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	switch(vtFld.vt) 
	{
	case VT_BSTR:
		//str = vtFld.bstrVal;
		str = ConvertBSTRToString(vtFld.bstrVal);
		break;
	case VT_I4:
		str = IntToStr(vtFld.iVal);
		break;
	case VT_DATE:
		{
			COleDateTime dt(vtFld);
			str = dt.Format("%Y-%m-%d %H:%M:%S");
		}
		break;
	case VT_EMPTY:
	case VT_NULL:
		break;
	default:
		strValue.Empty();
		return false;
	}
	strValue = str;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, CString& strValue, UINT *puLen)
{
	long nSize = m_pRecordset->GetFields()->GetItem(lpFieldName)->ActualSize;
	if(nSize > 0)
	{
		_variant_t	varBLOB;
		varBLOB = m_pRecordset->GetFields()->GetItem(lpFieldName)->GetChunk(nSize);
		if(varBLOB.vt == (VT_ARRAY | VT_UI1))
		{
			BYTE *pBuffer = (BYTE *)strValue.GetBufferSetLength(nSize);

			char *pBuf = NULL;
			SafeArrayAccessData(varBLOB.parray,(void **)&pBuf);
			memcpy(pBuffer, pBuf, nSize);	
			SafeArrayUnaccessData(varBLOB.parray);

			strValue.ReleaseBuffer(nSize);

			*puLen = nSize;
		}
	}

	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, CString& strValue)
{
	CString str = _T("");
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	switch(vtFld.vt) 
	{
	case VT_BSTR:
		//str = vtFld.bstrVal;
		str = ConvertBSTRToString(vtFld.bstrVal);
		break;
	case VT_DATE:
		{
			COleDateTime dt(vtFld);

			str = dt.Format("%Y-%m-%d %H:%M:%S");
		}
		break;
	case VT_EMPTY:
	case VT_NULL:
		break;
	default:
		strValue.Empty();
		return false;
	}
	strValue = str;
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, COleDateTime& time)
{
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	switch(vtFld.vt) 
	{
	case VT_DATE:
		{
			COleDateTime dt(vtFld);
			time = dt;
		}
		break;
	case VT_EMPTY:
	case VT_NULL:
		break;
	default:
		return false;
	}
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, COleDateTime& time)
{
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	switch(vtFld.vt) 
	{
	case VT_DATE:
		{
			COleDateTime dt(vtFld);
			time = dt;
		}
		break;
	case VT_EMPTY:
	case VT_NULL:
		break;
	default:
		return false;
	}
	return true;
}

bool CADORecordset::IsFieldNull(LPCTSTR lpFieldName)
{
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	return vtFld.vt == VT_NULL;
}

bool CADORecordset::IsFieldNull(int nIndex)
{
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	return vtFld.vt == VT_NULL;
}

bool CADORecordset::IsFieldEmpty(LPCTSTR lpFieldName)
{
	_variant_t vtFld;

	vtFld = m_pRecordset->Fields->GetItem(lpFieldName)->Value;
	return vtFld.vt == VT_EMPTY || vtFld.vt == VT_NULL;
}

bool CADORecordset::IsFieldEmpty(int nIndex)
{
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	vtFld = m_pRecordset->Fields->GetItem(vtIndex)->Value;
	return vtFld.vt == VT_EMPTY || vtFld.vt == VT_NULL;
}
bool CADORecordset::IsField(LPCTSTR lpFieldName)
{
	try
	{
		m_pRecordset->Fields->GetItem(lpFieldName);
	}
	catch(...)
	{
		return false;
	}	

	return true;
}
DWORD CADORecordset::GetRecordCount()
{
	DWORD nRows = 0;

	nRows = m_pRecordset->GetRecordCount();

	if(nRows == -1)
	{
		nRows = 0;
		if(m_pRecordset->EndOfFile != VARIANT_TRUE)
			m_pRecordset->MoveFirst();

		while(m_pRecordset->EndOfFile != VARIANT_TRUE)
		{
			nRows++;
			m_pRecordset->MoveNext();
		}
		if(nRows > 0)
			m_pRecordset->MoveFirst();
	}	
	return nRows;
}

bool CADORecordset::IsOpen()
{
	if(m_pRecordset)
		return m_pRecordset->GetState() != adStateClosed;
	return false;
}

void CADORecordset::Close()
{
	try
	{
		if(IsOpen())
			m_pRecordset->Close();
	}

	catch(_com_error &e)
	{
		dump_com_error(e);
	}		
}

bool CADODatabase::Execute(LPCTSTR lpstrExec)
{
	if (m_pConnection == NULL)
	{
		CString strEvent;
		strEvent.Format("- Connection is NULL.\n");
		DelLogDebugEvent("CADODatabase", "Execute", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}	
	if (strcmp(lpstrExec, _T("")) == 0)
	{
		CString strEvent;
		strEvent.Format("- Execute command is empty.\n");
		DelLogDebugEvent("CADODatabase", "Execute", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}	
	try
	{
		m_pConnection->Execute(_bstr_t(lpstrExec), NULL, adExecuteNoRecords);
	}
	catch(_com_error &e)
	{
		dump_com_error(e);
		return false;	
	}
	return true;	
}

//bool CADORecordset::RecordBinding(CADORecordBinding &pAdoRecordBinding)
//{
//	IADORecordBinding *picRs = NULL;
//	HRESULT hr;
//
//	//Open the binding interface.
//	if(FAILED(hr = m_pRecordset->QueryInterface(__uuidof(IADORecordBinding), (LPVOID*)&picRs )))
//	{
//		_com_issue_error(hr);
//		return false;
//	}
//	
//	//Bind the recordset to class
//	if(FAILED( hr = picRs->BindToRecordset(&pAdoRecordBinding)))
//	{
//		_com_issue_error(hr);
//		return false;
//	}
//	return true;
//}

void CADORecordset::dump_com_error(_com_error &e)
{
	CString ErrorStr;	

	_bstr_t bstrSource(e.Source());
	_bstr_t bstrDescription(e.Description());
	ErrorStr.Format( "CADORecordset Error\n\tCode = %08lx\n\tCode meaning = %s\n\tSource = %s\n\tDescription = %s\n",
		e.Error(), e.ErrorMessage(), (LPCSTR)bstrSource, (LPCSTR)bstrDescription );
	m_strLastError = _T("Query = " + GetQuery() + '\n' + ErrorStr);

	DelLogDebugEvent("CADORecordset", "dump_com_error", ErrorStr, eDELIMPORTANCE_LEVEL_HIGH, __FILE__, __LINE__);
}

bool CADORecordset::GetFieldInfo(LPCTSTR lpFieldName, CADOFieldInfo* fldInfo)
{
	_variant_t vtFld;
#if _MSC_VER >= 1300
	strcpy_s(fldInfo->m_strName,sizeof(fldInfo->m_strName), (LPCTSTR)m_pRecordset->Fields->GetItem(lpFieldName)->GetName());
#else
	strcpy(fldInfo->m_strName, (LPCTSTR)m_pRecordset->Fields->GetItem(lpFieldName)->GetName());
#endif

	fldInfo->m_lSize		= m_pRecordset->Fields->GetItem(lpFieldName)->GetActualSize();
	fldInfo->m_lDefinedSize = m_pRecordset->Fields->GetItem(lpFieldName)->GetDefinedSize();
	fldInfo->m_nType		= m_pRecordset->Fields->GetItem(lpFieldName)->GetType();
	fldInfo->m_lAttributes	= m_pRecordset->Fields->GetItem(lpFieldName)->GetAttributes();
	return true;
}

bool CADORecordset::GetFieldInfo(int nIndex, CADOFieldInfo* fldInfo)
{
	_variant_t vtFld;
	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

#if _MSC_VER >= 1300
	strcpy_s(fldInfo->m_strName,sizeof(fldInfo->m_strName), (LPCTSTR)m_pRecordset->Fields->GetItem(vtIndex)->GetName());
#else
	strcpy(fldInfo->m_strName, (LPCTSTR)m_pRecordset->Fields->GetItem(vtIndex)->GetName());
#endif

	fldInfo->m_lSize		= m_pRecordset->Fields->GetItem(vtIndex)->GetActualSize();
	fldInfo->m_lDefinedSize	= m_pRecordset->Fields->GetItem(vtIndex)->GetDefinedSize();
	fldInfo->m_nType		= m_pRecordset->Fields->GetItem(vtIndex)->GetType();
	fldInfo->m_lAttributes	= m_pRecordset->Fields->GetItem(vtIndex)->GetAttributes();
	return true;
}


bool CADORecordset::GetChunk(LPCTSTR lpFieldName, CString& strValue)
{
	CString str = _T("");
	long lngSize, lngOffSet = 0;
	_variant_t varChunk;    
	int ChunkSize = 100;

	lngSize = m_pRecordset->Fields->GetItem(lpFieldName)->ActualSize;

	str.Empty();
	while(lngOffSet < lngSize)
	{
		varChunk = m_pRecordset->Fields->GetItem(lpFieldName)->GetChunk(ChunkSize);
		str += varChunk.bstrVal;
		lngOffSet += ChunkSize;
	}

	lngOffSet = 0;
	strValue = str;
	return TRUE;
}

CString CADORecordset::GetString(LPCTSTR lpCols, LPCTSTR lpRows, LPCTSTR lpNull, long numRows)
{
	_bstr_t varOutput;
	_bstr_t varNull("");
	_bstr_t varCols("\t");
	_bstr_t varRows("\r");

	if(strlen(lpCols) != 0)
		varCols = _bstr_t(lpCols);

	if(strlen(lpRows) != 0)
		varRows = _bstr_t(lpRows);

	if(numRows == 0)
		numRows =(long)GetRecordCount();			

	varOutput = m_pRecordset->GetString(adClipString, numRows, varCols, varRows, varNull);

	return (LPCTSTR)varOutput;
}

CString IntToStr(int nVal)
{
	CString strRet;
	strRet.Format("%d",nVal);
	return strRet;
}

CString LongToStr(long lVal)
{
	CString strRet;
	strRet.Format("%d",lVal);
	return strRet;
}

void CADORecordset::Edit()
{
	m_nEditStatus = dbEdit;
}

bool CADORecordset::AddNew()
{
	m_nEditStatus = dbEditNone;
	if(m_pRecordset->AddNew() != S_OK)
		return false;

	m_nEditStatus = dbEditNew;
	return true;
}

bool CADORecordset::Update()
{
	bool bret = true;

	if(m_nEditStatus != dbEditNone)
	{
		if(m_pRecordset->Update() != S_OK)
			bret = false;
	}

	m_nEditStatus = dbEditNone;
	return bret;
}

void CADORecordset::CancelUpdate()
{
	m_pRecordset->CancelUpdate();
	m_nEditStatus = dbEditNone;
}

bool CADORecordset::SetFieldValue(int nIndex, CString strValue)
{
	if(strValue.IsEmpty()) return true;

	_variant_t vtFld;
	vtFld.vt = VT_BSTR;
	vtFld.bstrVal = _bstr_t(strValue);

	_variant_t vtIndex;	
	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	m_pRecordset->Fields->GetItem(vtIndex)->Value = _bstr_t(vtFld);//_bstr_t(strValue);
	return true;

}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, CString strValue)
{
	if(strValue.IsEmpty()) return true;

	_variant_t vtFld;
	vtFld.vt = VT_BSTR;
	vtFld.bstrVal = _bstr_t(strValue);

	m_pRecordset->Fields->GetItem(lpFieldName)->Value = _bstr_t(vtFld);//_bstr_t(strValue);
	return true;	
}

bool CADORecordset::SetFieldValue(int nIndex, int nValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_I2;
	vtFld.iVal = nValue;

	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	m_pRecordset->Fields->GetItem(vtIndex)->Value = vtFld;
	return true;
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, int nValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_I2;
	vtFld.iVal = nValue;

	m_pRecordset->Fields->GetItem(lpFieldName)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(int nIndex, long lValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_I4;
	vtFld.lVal = lValue;

	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	m_pRecordset->Fields->GetItem(vtIndex)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, long lValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_I4;
	vtFld.lVal = lValue;

	m_pRecordset->Fields->GetItem(lpFieldName)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(int nIndex, double dblValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_R8;
	vtFld.dblVal = dblValue;

	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	m_pRecordset->Fields->GetItem(vtIndex)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, double dblValue)
{
	_variant_t vtFld;
	vtFld.vt = VT_R8;
	vtFld.dblVal = dblValue;

	m_pRecordset->Fields->GetItem(lpFieldName)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(int nIndex, COleDateTime time)
{
	_variant_t vtFld;
	vtFld.vt = VT_DATE;
	vtFld.date = time;

	_variant_t vtIndex;

	vtIndex.vt = VT_I2;
	vtIndex.iVal = nIndex;

	m_pRecordset->Fields->GetItem(vtIndex)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, COleDateTime time)
{
	_variant_t vtFld;
	vtFld.vt = VT_DATE;
	vtFld.date = time;

	m_pRecordset->Fields->GetItem(lpFieldName)->Value = vtFld;
	return true;	
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, BYTE *pBlob, UINT uLen)
{
	_variant_t		varBLOB;
	SAFEARRAY		*psa;
	SAFEARRAYBOUND	rgsabound[1];

	if(pBlob)
	{    
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = uLen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
		for (long i = 0; i < (long)uLen; i++)
			SafeArrayPutElement (psa, &i, pBlob++);
		varBLOB.vt = VT_ARRAY | VT_UI1;
		varBLOB.parray = psa;

		m_pRecordset->GetFields()->GetItem(lpFieldName)->AppendChunk(varBLOB);	
	}
	return true;
}

bool CADORecordset::SetFieldValue(int nIndex, BYTE *pBlob, UINT uLen)
{
	_variant_t		varBLOB;
	SAFEARRAY		*psa;
	SAFEARRAYBOUND	rgsabound[1];

	if(pBlob)
	{    
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = uLen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);
		for (long i = 0; i < (long)uLen; i++)
			SafeArrayPutElement (psa, &i, pBlob++);
		varBLOB.vt = VT_ARRAY | VT_UI1;
		varBLOB.parray = psa;

		m_pRecordset->GetFields()->GetItem(nIndex)->AppendChunk(varBLOB);	
	}
	return true;
}

bool CADORecordset::SetBookmark()
{
	if(m_varBookmark.vt != VT_EMPTY)
	{
		m_pRecordset->Bookmark = m_varBookmark;
		return true;
	}
	return false;
}

bool CADORecordset::Delete()
{
	if(m_pRecordset->Delete(adAffectCurrent) != S_OK)
		return false;
	if(m_pRecordset->Update() != S_OK)
		return false;
	return true;
}

bool CADORecordset::Find(LPCTSTR lpFind, int nSearchDirection)
{
	m_strFind = lpFind;
	m_nSearchDirection = nSearchDirection;

	if (m_strFind.IsEmpty())
	{
		CString strEvent;
		strEvent.Format("- Search string is empty.\n");
		DelLogDebugEvent("CADORecordset", "Find", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		return false;
	}	
	if(m_nSearchDirection == searchForward)
	{
		m_pRecordset->Find(_bstr_t(m_strFind), 0, adSearchForward, "");
		if(!IsEof())
		{
			m_varBookFind = m_pRecordset->Bookmark;
			return true;
		}
	}
	else if(m_nSearchDirection == searchBackward)
	{
		m_pRecordset->Find(_bstr_t(m_strFind), 0, adSearchBackward, "");
		if(!IsBof())
		{
			m_varBookFind = m_pRecordset->Bookmark;
			return true;
		}
	}
	else
	{
		CString strEvent;
		strEvent.Format("- Invalid search direction (%d).\n", nSearchDirection);
		DelLogDebugEvent("CADORecordset", "Find", strEvent, eDELIMPORTANCE_LEVEL_HIGHEST, __FILE__, __LINE__);
		m_nSearchDirection = searchForward;
	}
	return false;
}

bool CADORecordset::FindFirst(LPCTSTR lpFind)
{
	m_pRecordset->MoveFirst();
	return Find(lpFind);
}

bool CADORecordset::FindNext()
{
	if(m_nSearchDirection == searchForward)
	{
		m_pRecordset->Find(_bstr_t(m_strFind), 1, adSearchForward, m_varBookFind);
		if(!IsEof())
		{
			m_varBookFind = m_pRecordset->Bookmark;
			return true;
		}
	}
	else
	{
		m_pRecordset->Find(_bstr_t(m_strFind), 1, adSearchBackward, m_varBookFind);
		if(!IsBof())
		{
			m_varBookFind = m_pRecordset->Bookmark;
			return true;
		}
	}
	return false;
}

bool CADORecordset::Supports(int nCursorOption)
{
	if(TRUE == m_pRecordset->Supports((CursorOptionEnum)nCursorOption))
		return true;
	return false;
}

bool CADORecordset::CanAppend()
{
	if (TRUE == m_pRecordset->Supports(adAddNew))
		return true;
	return false;
}

bool CADORecordset::CanBookmark()
{
	if (TRUE == m_pRecordset->Supports(adBookmark))
		return true;
	return false;
}

bool CADORecordset::CanResync()
{
	if (TRUE == m_pRecordset->Supports(adResync))
		return true;
	return false;
}

bool CADORecordset::CanUpdate()
{
	if (TRUE == m_pRecordset->Supports(adUpdate))
		return true;
	return false;
}

bool CADORecordset::Requery()
{
	HRESULT hr = S_OK;
	hr = m_pRecordset->Requery(adCmdUnknown);
	return (hr == S_OK);
}

bool CADORecordset::Resync()
{
	HRESULT hr = S_OK;
	hr = m_pRecordset->Resync(adAffectAll, adResyncAllValues);
	return (hr == S_OK);
}

int CADORecordset::GetCursorLocation()
{
	return (enum cadoCursorLocationEnum)m_pRecordset->GetCursorLocation();
}

void CADORecordset::SetCursorLocation(int nCursorLocation)
{
	m_nCursorLocation = (enum cadoCursorLocationEnum)nCursorLocation;
}

int CADORecordset::GetCursorType()
{
	return (enum cadoCursorTypeEnum)m_pRecordset->GetCursorType();
}

void CADORecordset::SetCursorType(int nCursorType)
{
	m_nCursorType = (enum cadoCursorTypeEnum)nCursorType;
}

int CADORecordset::GetLockType()
{
	return (enum cadoLockTypeEnum)m_pRecordset->GetLockType();
}

void CADORecordset::SetLockType(int nLockType)
{
	m_nLockType = (enum cadoLockTypeEnum)nLockType;
}

void CADORecordset::SetFilter(CString strFilter)
{
	m_pRecordset->Filter = (LPCSTR)strFilter;
}

void CADORecordset::SetFilter(int nFilterType)
{
	_variant_t vtFilterType;	
	vtFilterType.vt = VT_I2;
	vtFilterType.iVal = nFilterType;
	m_pRecordset->Filter = vtFilterType;
}

void CADORecordset::SetSortOrder(CString strSort)
{
	m_pRecordset->Sort = (LPCSTR)strSort;
}

bool CADORecordset::NextRecordset()
{
	m_pRecordset = m_pRecordset->NextRecordset(NULL);
	if (m_pRecordset) return true;
	return false;
}

//////////////////////////////////////////////////////////////////////////
bool CADORecordset::SetFieldValue(int nIndex, int nFileType, CString strFileName)
{
	try
	{
		switch(nFileType)
		{
		case ADO_FIELD_IMAGE:
			{
				ASSERT(!strFileName.IsEmpty());
				CFile file;
				DWORD dwFileSize;
				char* pBitBuffer;
				VARIANT bitData = {0};
				try
				{
					file.Open(strFileName, CFile::modeRead);
					dwFileSize = (DWORD)(file.GetLength() + 1);
					pBitBuffer = new char[dwFileSize];

					file.Read(pBitBuffer, dwFileSize);
					file.Close();
				}
				catch(CFileException * e)
				{
					e->ReportError();
					e->Delete();		
					file.Close();
					return false;
				}

				SetFieldValue(nIndex, (BYTE*)pBitBuffer, (UINT)dwFileSize);
				delete pBitBuffer;
			}
			break;
		case ADO_FIELD_TEXT:
			{
				VARIANT varData;
				SAFEARRAY* pSafeArray;
				SAFEARRAYBOUND arrayBound;
				char *pBuf;

				varData.vt = VT_ARRAY | VT_UI1;
				arrayBound.cElements = strFileName.GetLength();
				arrayBound.lLbound = 0;
				pSafeArray = ::SafeArrayCreate(VT_UI1, 1, &arrayBound);
				pBuf = strFileName.GetBuffer(0);
				for(unsigned long i = 0; i < arrayBound.cElements; i++)
					::SafeArrayPutElement(pSafeArray, (long*)&i, pBuf++);
				varData.parray = pSafeArray;

				m_pRecordset->GetFields()->GetItem(nIndex)->AppendChunk(varData);
			}
			break;
		default:
			break;
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.Description());
		return false;
	}
	return true;
}

bool CADORecordset::SetFieldValue(LPCTSTR lpFieldName, int nFileType, CString strFileName)
{
	try
	{
		switch(nFileType)
		{
		case ADO_FIELD_IMAGE:
			{
				ASSERT(!strFileName.IsEmpty());
				CFile file;
				DWORD dwFileSize;
				char* pBitBuffer;
				VARIANT bitData = {0};
				try
				{
					file.Open(strFileName, CFile::modeRead);
					dwFileSize = (DWORD)(file.GetLength() + 1);
					pBitBuffer = new char[dwFileSize];

					file.Read(pBitBuffer, dwFileSize);
					file.Close();
				}
				catch(CFileException * e)
				{
					e->ReportError();
					e->Delete();		
					file.Close();
					return false;
				}

				SetFieldValue(lpFieldName, (BYTE*)pBitBuffer, (UINT)dwFileSize);
				delete pBitBuffer;
			}
			break;
		case ADO_FIELD_TEXT:
			{
				VARIANT varData;
				SAFEARRAY* pSafeArray;
				SAFEARRAYBOUND arrayBound;
				char *pBuf;

				varData.vt = VT_ARRAY | VT_UI1;
				arrayBound.cElements = strFileName.GetLength();
				arrayBound.lLbound = 0;
				pSafeArray = ::SafeArrayCreate(VT_UI1, 1, &arrayBound);
				pBuf = strFileName.GetBuffer(0);
				for(unsigned long i = 0; i < arrayBound.cElements; i++)
					::SafeArrayPutElement(pSafeArray, (long*)&i, pBuf++);
				varData.parray = pSafeArray;

				m_pRecordset->GetFields()->GetItem(lpFieldName)->AppendChunk(varData);
			}
			break;
		default:
			break;
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.Description());
		return false;
	}
	return true;
}
//////////////////////////////////////////////////////////////////////////
bool CADORecordset::GetFieldValue(int nIndex, HBITMAP &hBitmap, CDC* pDC)
{
	_variant_t variant;
	try
	{
		long lBits;

		lBits = m_pRecordset->GetFields()->GetItem(nIndex)->ActualSize;
		if(lBits <= 0)
			return true;
		variant = m_pRecordset->GetFields()->GetItem(nIndex)->GetChunk(lBits);

		if(variant.vt == VT_NULL)
			return false;
		char *pBuffer;
		if((pBuffer = new char[lBits]) != NULL)
		{
			if(variant.vt == (VT_ARRAY | VT_UI1))
			{
				char *pBuf;
				::SafeArrayAccessData(variant.parray, (void**)&pBuf);
				::memcpy(pBuffer, pBuf, lBits);
				::SafeArrayUnaccessData(variant.parray);

				char *pDib;
				LPVOID lpDibBits;
				BITMAPFILEHEADER &bmfHeader = *(BITMAPFILEHEADER*)pBuffer;
				DWORD bmfHeaderLen = sizeof(bmfHeader);
				if(bmfHeader.bfType != (*(DWORD*)"BM"))
					return true;
				pDib = pBuffer + bmfHeaderLen;
				BITMAPINFOHEADER &bmiHeader = *(LPBITMAPINFOHEADER)pDib;
				BITMAPINFO &bmInfo = *(LPBITMAPINFO)pDib;
				lpDibBits = pBuffer + ((BITMAPFILEHEADER*)pBuffer)->bfOffBits;

				hBitmap = ::CreateDIBitmap(pDC->m_hDC, &bmiHeader, CBM_INIT, lpDibBits, &bmInfo, DIB_RGB_COLORS);
			}
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.Description());
		return false;
	}
	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName, HBITMAP &hBitmap, CDC* pDC)
{
	ASSERT(lpFieldName != NULL);
	_variant_t variant;
	try
	{
		long lBits;

		lBits = m_pRecordset->GetFields()->GetItem(lpFieldName)->ActualSize;
		if(lBits <= 0)
			return true;
		variant = m_pRecordset->GetFields()->GetItem(lpFieldName)->GetChunk(lBits);

		if(variant.vt == VT_NULL)
			return false;
		char *pBuffer;
		if((pBuffer = new char[lBits]) != NULL)
		{
			if(variant.vt == (VT_ARRAY | VT_UI1))
			{
				char *pBuf;
				::SafeArrayAccessData(variant.parray, (void**)&pBuf);
				::memcpy(pBuffer, pBuf, lBits);
				::SafeArrayUnaccessData(variant.parray);

				char *pDib;
				LPVOID lpDibBits;
				BITMAPFILEHEADER &bmfHeader = *(BITMAPFILEHEADER*)pBuffer;
				DWORD bmfHeaderLen = sizeof(bmfHeader);
				if(bmfHeader.bfType != (*(DWORD*)"BM"))
					return true;
				pDib = pBuffer + bmfHeaderLen;
				BITMAPINFOHEADER &bmiHeader = *(LPBITMAPINFOHEADER)pDib;
				BITMAPINFO &bmInfo = *(LPBITMAPINFO)pDib;
				lpDibBits = pBuffer + ((BITMAPFILEHEADER*)pBuffer)->bfOffBits;

				hBitmap = ::CreateDIBitmap(pDC->m_hDC, &bmiHeader, CBM_INIT, lpDibBits, &bmInfo, DIB_RGB_COLORS);
			}
		}
	}
	catch(_com_error e)
	{
		AfxMessageBox(e.Description());
		return false;
	}
	return true;
}

bool CADORecordset::GetFieldValue(int nIndex, CString *pText)
{
	long lBits;

	lBits = m_pRecordset->GetFields()->GetItem(nIndex)->ActualSize;
	if(lBits <= 0)
		return true;
	_variant_t variant = m_pRecordset->GetFields()->GetItem(nIndex)->GetChunk(lBits);
	pText->Format("%s", (char*)(_bstr_t)variant);

	return true;
}

bool CADORecordset::GetFieldValue(LPCTSTR lpFieldName,  CString *pText)
{
	long lBits;

	lBits = m_pRecordset->GetFields()->GetItem(lpFieldName)->ActualSize;
	if(lBits <= 0)
		return true;
	_variant_t variant = m_pRecordset->GetFields()->GetItem(lpFieldName)->GetChunk(lBits);
	pText->Format("%s", (char*)(_bstr_t)variant);

	return true;
}

bool CADORecordset::GetFieldValue( LPCTSTR lpFieldName, char* sValue )
{
	CString strValue;
	if (GetFieldValue(lpFieldName,strValue))
	{
		if (!strValue.IsEmpty())
		{
			strcpy(sValue,strValue);
		}
		else
		{
			sValue[0]=0;
		}
		return true;
	}
	return false;
}

bool CADORecordset::GetFieldValue( int nIndex, char* sValue )
{
	CString strValue;
	if (GetFieldValue(nIndex,strValue))
	{
		if (!strValue.IsEmpty())
		{
			strcpy(sValue,strValue);
		}
		else
		{
			sValue[0]=0;
		}
		return true;
	}
	return false;
}
//////////////////////////////////////////////////////////////////////////