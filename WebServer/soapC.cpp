/* soapC.cpp
   Generated by gSOAP 2.8.23 from clientservice.h

Copyright(C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif


#include "..\StdAfx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.23 2021-04-13 01:17:24 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns1__AuthHeader:
		return soap_in_ns1__AuthHeader(soap, NULL, NULL, "ns1:AuthHeader");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__UpdateQuery:
		return soap_in_PointerTo_ns1__UpdateQuery(soap, NULL, NULL, "ns1:UpdateQuery");
	case SOAP_TYPE_PointerTo_ns1__GetQuery:
		return soap_in_PointerTo_ns1__GetQuery(soap, NULL, NULL, "ns1:GetQuery");
	case SOAP_TYPE_PointerTo_ns1__UploadFile:
		return soap_in_PointerTo_ns1__UploadFile(soap, NULL, NULL, "ns1:UploadFile");
	case SOAP_TYPE_PointerTo_ns1__SyncReportState:
		return soap_in_PointerTo_ns1__SyncReportState(soap, NULL, NULL, "ns1:SyncReportState");
	case SOAP_TYPE_PointerTo_ns1__UpdateDataState:
		return soap_in_PointerTo_ns1__UpdateDataState(soap, NULL, NULL, "ns1:UpdateDataState");
	case SOAP_TYPE_PointerTo_ns1__SyncDataState:
		return soap_in_PointerTo_ns1__SyncDataState(soap, NULL, NULL, "ns1:SyncDataState");
	case SOAP_TYPE_PointerTo_ns1__UpdatePatientInfo:
		return soap_in_PointerTo_ns1__UpdatePatientInfo(soap, NULL, NULL, "ns1:UpdatePatientInfo");
	case SOAP_TYPE_PointerTo_ns1__SyncPatientInfo:
		return soap_in_PointerTo_ns1__SyncPatientInfo(soap, NULL, NULL, "ns1:SyncPatientInfo");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_in_PointerTo_ns1__Login(soap, NULL, NULL, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__GetReportState:
		return soap_in_PointerTo_ns1__GetReportState(soap, NULL, NULL, "ns1:GetReportState");
	case SOAP_TYPE_PointerTons1__AuthHeader:
		return soap_in_PointerTons1__AuthHeader(soap, NULL, NULL, "ns1:AuthHeader");
	case SOAP_TYPE_PointerTo_ns1__GetQueryResponse_GetQueryResult:
		return soap_in_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, NULL, NULL, "ns1:GetQueryResponse-GetQueryResult");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetReportStateResponse_GetReportStateResult:
		return soap_in_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, NULL, NULL, "ns1:GetReportStateResponse-GetReportStateResult");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:AuthHeader"))
		{	*type = SOAP_TYPE_ns1__AuthHeader;
			return soap_in_ns1__AuthHeader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:GetQueryResponse-GetQueryResult"))
		{	*type = SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult;
			return soap_in__ns1__GetQueryResponse_GetQueryResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReportStateResponse-GetReportStateResult"))
		{	*type = SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult;
			return soap_in__ns1__GetReportStateResponse_GetReportStateResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateQueryResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateQueryResponse;
			return soap_in__ns1__UpdateQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateQuery"))
		{	*type = SOAP_TYPE__ns1__UpdateQuery;
			return soap_in__ns1__UpdateQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetQueryResponse"))
		{	*type = SOAP_TYPE__ns1__GetQueryResponse;
			return soap_in__ns1__GetQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetQuery"))
		{	*type = SOAP_TYPE__ns1__GetQuery;
			return soap_in__ns1__GetQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadFileResponse"))
		{	*type = SOAP_TYPE__ns1__UploadFileResponse;
			return soap_in__ns1__UploadFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UploadFile"))
		{	*type = SOAP_TYPE__ns1__UploadFile;
			return soap_in__ns1__UploadFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncReportStateResponse"))
		{	*type = SOAP_TYPE__ns1__SyncReportStateResponse;
			return soap_in__ns1__SyncReportStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncReportState"))
		{	*type = SOAP_TYPE__ns1__SyncReportState;
			return soap_in__ns1__SyncReportState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDataStateResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateDataStateResponse;
			return soap_in__ns1__UpdateDataStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateDataState"))
		{	*type = SOAP_TYPE__ns1__UpdateDataState;
			return soap_in__ns1__UpdateDataState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncDataStateResponse"))
		{	*type = SOAP_TYPE__ns1__SyncDataStateResponse;
			return soap_in__ns1__SyncDataStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncDataState"))
		{	*type = SOAP_TYPE__ns1__SyncDataState;
			return soap_in__ns1__SyncDataState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePatientInfoResponse"))
		{	*type = SOAP_TYPE__ns1__UpdatePatientInfoResponse;
			return soap_in__ns1__UpdatePatientInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePatientInfo"))
		{	*type = SOAP_TYPE__ns1__UpdatePatientInfo;
			return soap_in__ns1__UpdatePatientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncPatientInfoResponse"))
		{	*type = SOAP_TYPE__ns1__SyncPatientInfoResponse;
			return soap_in__ns1__SyncPatientInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SyncPatientInfo"))
		{	*type = SOAP_TYPE__ns1__SyncPatientInfo;
			return soap_in__ns1__SyncPatientInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LoginResponse"))
		{	*type = SOAP_TYPE__ns1__LoginResponse;
			return soap_in__ns1__LoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Login"))
		{	*type = SOAP_TYPE__ns1__Login;
			return soap_in__ns1__Login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReportStateResponse"))
		{	*type = SOAP_TYPE__ns1__GetReportStateResponse;
			return soap_in__ns1__GetReportStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetReportState"))
		{	*type = SOAP_TYPE__ns1__GetReportState;
			return soap_in__ns1__GetReportState(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult:
		return ((_ns1__GetQueryResponse_GetQueryResult *)ptr)->soap_out(soap, "ns1:GetQueryResponse-GetQueryResult", id, NULL);
	case SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult:
		return ((_ns1__GetReportStateResponse_GetReportStateResult *)ptr)->soap_out(soap, "ns1:GetReportStateResponse-GetReportStateResult", id, NULL);
	case SOAP_TYPE__ns1__UpdateQueryResponse:
		return ((_ns1__UpdateQueryResponse *)ptr)->soap_out(soap, "ns1:UpdateQueryResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateQuery:
		return ((_ns1__UpdateQuery *)ptr)->soap_out(soap, "ns1:UpdateQuery", id, NULL);
	case SOAP_TYPE__ns1__GetQueryResponse:
		return ((_ns1__GetQueryResponse *)ptr)->soap_out(soap, "ns1:GetQueryResponse", id, NULL);
	case SOAP_TYPE__ns1__GetQuery:
		return ((_ns1__GetQuery *)ptr)->soap_out(soap, "ns1:GetQuery", id, NULL);
	case SOAP_TYPE__ns1__UploadFileResponse:
		return ((_ns1__UploadFileResponse *)ptr)->soap_out(soap, "ns1:UploadFileResponse", id, NULL);
	case SOAP_TYPE__ns1__UploadFile:
		return ((_ns1__UploadFile *)ptr)->soap_out(soap, "ns1:UploadFile", id, NULL);
	case SOAP_TYPE__ns1__SyncReportStateResponse:
		return ((_ns1__SyncReportStateResponse *)ptr)->soap_out(soap, "ns1:SyncReportStateResponse", id, NULL);
	case SOAP_TYPE__ns1__SyncReportState:
		return ((_ns1__SyncReportState *)ptr)->soap_out(soap, "ns1:SyncReportState", id, NULL);
	case SOAP_TYPE__ns1__UpdateDataStateResponse:
		return ((_ns1__UpdateDataStateResponse *)ptr)->soap_out(soap, "ns1:UpdateDataStateResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateDataState:
		return ((_ns1__UpdateDataState *)ptr)->soap_out(soap, "ns1:UpdateDataState", id, NULL);
	case SOAP_TYPE__ns1__SyncDataStateResponse:
		return ((_ns1__SyncDataStateResponse *)ptr)->soap_out(soap, "ns1:SyncDataStateResponse", id, NULL);
	case SOAP_TYPE__ns1__SyncDataState:
		return ((_ns1__SyncDataState *)ptr)->soap_out(soap, "ns1:SyncDataState", id, NULL);
	case SOAP_TYPE__ns1__UpdatePatientInfoResponse:
		return ((_ns1__UpdatePatientInfoResponse *)ptr)->soap_out(soap, "ns1:UpdatePatientInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdatePatientInfo:
		return ((_ns1__UpdatePatientInfo *)ptr)->soap_out(soap, "ns1:UpdatePatientInfo", id, NULL);
	case SOAP_TYPE__ns1__SyncPatientInfoResponse:
		return ((_ns1__SyncPatientInfoResponse *)ptr)->soap_out(soap, "ns1:SyncPatientInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__SyncPatientInfo:
		return ((_ns1__SyncPatientInfo *)ptr)->soap_out(soap, "ns1:SyncPatientInfo", id, NULL);
	case SOAP_TYPE__ns1__LoginResponse:
		return ((_ns1__LoginResponse *)ptr)->soap_out(soap, "ns1:LoginResponse", id, NULL);
	case SOAP_TYPE__ns1__Login:
		return ((_ns1__Login *)ptr)->soap_out(soap, "ns1:Login", id, NULL);
	case SOAP_TYPE__ns1__GetReportStateResponse:
		return ((_ns1__GetReportStateResponse *)ptr)->soap_out(soap, "ns1:GetReportStateResponse", id, NULL);
	case SOAP_TYPE__ns1__GetReportState:
		return ((_ns1__GetReportState *)ptr)->soap_out(soap, "ns1:GetReportState", id, NULL);
	case SOAP_TYPE_ns1__AuthHeader:
		return ((ns1__AuthHeader *)ptr)->soap_out(soap, tag, id, "ns1:AuthHeader");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__UpdateQuery:
		return soap_out_PointerTo_ns1__UpdateQuery(soap, tag, id, (_ns1__UpdateQuery *const*)ptr, "ns1:UpdateQuery");
	case SOAP_TYPE_PointerTo_ns1__GetQuery:
		return soap_out_PointerTo_ns1__GetQuery(soap, tag, id, (_ns1__GetQuery *const*)ptr, "ns1:GetQuery");
	case SOAP_TYPE_PointerTo_ns1__UploadFile:
		return soap_out_PointerTo_ns1__UploadFile(soap, tag, id, (_ns1__UploadFile *const*)ptr, "ns1:UploadFile");
	case SOAP_TYPE_PointerTo_ns1__SyncReportState:
		return soap_out_PointerTo_ns1__SyncReportState(soap, tag, id, (_ns1__SyncReportState *const*)ptr, "ns1:SyncReportState");
	case SOAP_TYPE_PointerTo_ns1__UpdateDataState:
		return soap_out_PointerTo_ns1__UpdateDataState(soap, tag, id, (_ns1__UpdateDataState *const*)ptr, "ns1:UpdateDataState");
	case SOAP_TYPE_PointerTo_ns1__SyncDataState:
		return soap_out_PointerTo_ns1__SyncDataState(soap, tag, id, (_ns1__SyncDataState *const*)ptr, "ns1:SyncDataState");
	case SOAP_TYPE_PointerTo_ns1__UpdatePatientInfo:
		return soap_out_PointerTo_ns1__UpdatePatientInfo(soap, tag, id, (_ns1__UpdatePatientInfo *const*)ptr, "ns1:UpdatePatientInfo");
	case SOAP_TYPE_PointerTo_ns1__SyncPatientInfo:
		return soap_out_PointerTo_ns1__SyncPatientInfo(soap, tag, id, (_ns1__SyncPatientInfo *const*)ptr, "ns1:SyncPatientInfo");
	case SOAP_TYPE_PointerTo_ns1__Login:
		return soap_out_PointerTo_ns1__Login(soap, tag, id, (_ns1__Login *const*)ptr, "ns1:Login");
	case SOAP_TYPE_PointerTo_ns1__GetReportState:
		return soap_out_PointerTo_ns1__GetReportState(soap, tag, id, (_ns1__GetReportState *const*)ptr, "ns1:GetReportState");
	case SOAP_TYPE_PointerTons1__AuthHeader:
		return soap_out_PointerTons1__AuthHeader(soap, tag, id, (ns1__AuthHeader *const*)ptr, "ns1:AuthHeader");
	case SOAP_TYPE_PointerTo_ns1__GetQueryResponse_GetQueryResult:
		return soap_out_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, tag, id, (_ns1__GetQueryResponse_GetQueryResult *const*)ptr, "ns1:GetQueryResponse-GetQueryResult");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTo_ns1__GetReportStateResponse_GetReportStateResult:
		return soap_out_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, tag, id, (_ns1__GetReportStateResponse_GetReportStateResult *const*)ptr, "ns1:GetReportStateResponse-GetReportStateResult");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult:
		((_ns1__GetQueryResponse_GetQueryResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult:
		((_ns1__GetReportStateResponse_GetReportStateResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateQueryResponse:
		((_ns1__UpdateQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateQuery:
		((_ns1__UpdateQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetQueryResponse:
		((_ns1__GetQueryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetQuery:
		((_ns1__GetQuery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadFileResponse:
		((_ns1__UploadFileResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UploadFile:
		((_ns1__UploadFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncReportStateResponse:
		((_ns1__SyncReportStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncReportState:
		((_ns1__SyncReportState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDataStateResponse:
		((_ns1__UpdateDataStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateDataState:
		((_ns1__UpdateDataState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncDataStateResponse:
		((_ns1__SyncDataStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncDataState:
		((_ns1__SyncDataState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePatientInfoResponse:
		((_ns1__UpdatePatientInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePatientInfo:
		((_ns1__UpdatePatientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncPatientInfoResponse:
		((_ns1__SyncPatientInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__SyncPatientInfo:
		((_ns1__SyncPatientInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		((_ns1__LoginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Login:
		((_ns1__Login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReportStateResponse:
		((_ns1__GetReportStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetReportState:
		((_ns1__GetReportState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AuthHeader:
		((ns1__AuthHeader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__UpdateQuery_:
		soap_serialize___ns1__UpdateQuery_(soap, (const struct __ns1__UpdateQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetQuery_:
		soap_serialize___ns1__GetQuery_(soap, (const struct __ns1__GetQuery_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadFile_:
		soap_serialize___ns1__UploadFile_(soap, (const struct __ns1__UploadFile_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncReportState_:
		soap_serialize___ns1__SyncReportState_(soap, (const struct __ns1__SyncReportState_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateDataState_:
		soap_serialize___ns1__UpdateDataState_(soap, (const struct __ns1__UpdateDataState_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncDataState_:
		soap_serialize___ns1__SyncDataState_(soap, (const struct __ns1__SyncDataState_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePatientInfo_:
		soap_serialize___ns1__UpdatePatientInfo_(soap, (const struct __ns1__UpdatePatientInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncPatientInfo_:
		soap_serialize___ns1__SyncPatientInfo_(soap, (const struct __ns1__SyncPatientInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Login_:
		soap_serialize___ns1__Login_(soap, (const struct __ns1__Login_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetReportState_:
		soap_serialize___ns1__GetReportState_(soap, (const struct __ns1__GetReportState_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateQuery:
		soap_serialize___ns1__UpdateQuery(soap, (const struct __ns1__UpdateQuery *)ptr);
		break;
	case SOAP_TYPE___ns1__GetQuery:
		soap_serialize___ns1__GetQuery(soap, (const struct __ns1__GetQuery *)ptr);
		break;
	case SOAP_TYPE___ns1__UploadFile:
		soap_serialize___ns1__UploadFile(soap, (const struct __ns1__UploadFile *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncReportState:
		soap_serialize___ns1__SyncReportState(soap, (const struct __ns1__SyncReportState *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateDataState:
		soap_serialize___ns1__UpdateDataState(soap, (const struct __ns1__UpdateDataState *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncDataState:
		soap_serialize___ns1__SyncDataState(soap, (const struct __ns1__SyncDataState *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePatientInfo:
		soap_serialize___ns1__UpdatePatientInfo(soap, (const struct __ns1__UpdatePatientInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__SyncPatientInfo:
		soap_serialize___ns1__SyncPatientInfo(soap, (const struct __ns1__SyncPatientInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__Login:
		soap_serialize___ns1__Login(soap, (const struct __ns1__Login *)ptr);
		break;
	case SOAP_TYPE___ns1__GetReportState:
		soap_serialize___ns1__GetReportState(soap, (const struct __ns1__GetReportState *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateQuery:
		soap_serialize_PointerTo_ns1__UpdateQuery(soap, (_ns1__UpdateQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetQuery:
		soap_serialize_PointerTo_ns1__GetQuery(soap, (_ns1__GetQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UploadFile:
		soap_serialize_PointerTo_ns1__UploadFile(soap, (_ns1__UploadFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SyncReportState:
		soap_serialize_PointerTo_ns1__SyncReportState(soap, (_ns1__SyncReportState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateDataState:
		soap_serialize_PointerTo_ns1__UpdateDataState(soap, (_ns1__UpdateDataState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SyncDataState:
		soap_serialize_PointerTo_ns1__SyncDataState(soap, (_ns1__SyncDataState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePatientInfo:
		soap_serialize_PointerTo_ns1__UpdatePatientInfo(soap, (_ns1__UpdatePatientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__SyncPatientInfo:
		soap_serialize_PointerTo_ns1__SyncPatientInfo(soap, (_ns1__SyncPatientInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Login:
		soap_serialize_PointerTo_ns1__Login(soap, (_ns1__Login *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReportState:
		soap_serialize_PointerTo_ns1__GetReportState(soap, (_ns1__GetReportState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuthHeader:
		soap_serialize_PointerTons1__AuthHeader(soap, (ns1__AuthHeader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetQueryResponse_GetQueryResult:
		soap_serialize_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, (_ns1__GetQueryResponse_GetQueryResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetReportStateResponse_GetReportStateResult:
		soap_serialize_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, (_ns1__GetReportStateResponse_GetReportStateResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthHeader:
		return (void*)soap_instantiate_ns1__AuthHeader(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReportState:
		return (void*)soap_instantiate__ns1__GetReportState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult:
		return (void*)soap_instantiate__ns1__GetReportStateResponse_GetReportStateResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetReportStateResponse:
		return (void*)soap_instantiate__ns1__GetReportStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Login:
		return (void*)soap_instantiate__ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__LoginResponse:
		return (void*)soap_instantiate__ns1__LoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncPatientInfo:
		return (void*)soap_instantiate__ns1__SyncPatientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncPatientInfoResponse:
		return (void*)soap_instantiate__ns1__SyncPatientInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePatientInfo:
		return (void*)soap_instantiate__ns1__UpdatePatientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePatientInfoResponse:
		return (void*)soap_instantiate__ns1__UpdatePatientInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncDataState:
		return (void*)soap_instantiate__ns1__SyncDataState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncDataStateResponse:
		return (void*)soap_instantiate__ns1__SyncDataStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDataState:
		return (void*)soap_instantiate__ns1__UpdateDataState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateDataStateResponse:
		return (void*)soap_instantiate__ns1__UpdateDataStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncReportState:
		return (void*)soap_instantiate__ns1__SyncReportState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__SyncReportStateResponse:
		return (void*)soap_instantiate__ns1__SyncReportStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadFile:
		return (void*)soap_instantiate__ns1__UploadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UploadFileResponse:
		return (void*)soap_instantiate__ns1__UploadFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetQuery:
		return (void*)soap_instantiate__ns1__GetQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult:
		return (void*)soap_instantiate__ns1__GetQueryResponse_GetQueryResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetQueryResponse:
		return (void*)soap_instantiate__ns1__GetQueryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateQuery:
		return (void*)soap_instantiate__ns1__UpdateQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateQueryResponse:
		return (void*)soap_instantiate__ns1__UpdateQueryResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__GetReportState:
		return (void*)soap_instantiate___ns1__GetReportState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Login:
		return (void*)soap_instantiate___ns1__Login(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncPatientInfo:
		return (void*)soap_instantiate___ns1__SyncPatientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdatePatientInfo:
		return (void*)soap_instantiate___ns1__UpdatePatientInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncDataState:
		return (void*)soap_instantiate___ns1__SyncDataState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateDataState:
		return (void*)soap_instantiate___ns1__UpdateDataState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncReportState:
		return (void*)soap_instantiate___ns1__SyncReportState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadFile:
		return (void*)soap_instantiate___ns1__UploadFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetQuery:
		return (void*)soap_instantiate___ns1__GetQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateQuery:
		return (void*)soap_instantiate___ns1__UpdateQuery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetReportState_:
		return (void*)soap_instantiate___ns1__GetReportState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Login_:
		return (void*)soap_instantiate___ns1__Login_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncPatientInfo_:
		return (void*)soap_instantiate___ns1__SyncPatientInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdatePatientInfo_:
		return (void*)soap_instantiate___ns1__UpdatePatientInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncDataState_:
		return (void*)soap_instantiate___ns1__SyncDataState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateDataState_:
		return (void*)soap_instantiate___ns1__UpdateDataState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__SyncReportState_:
		return (void*)soap_instantiate___ns1__SyncReportState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UploadFile_:
		return (void*)soap_instantiate___ns1__UploadFile_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetQuery_:
		return (void*)soap_instantiate___ns1__GetQuery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateQuery_:
		return (void*)soap_instantiate___ns1__UpdateQuery_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(static_cast<xsd__base64Binary*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<xsd__base64Binary*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__AuthHeader:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__AuthHeader*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__AuthHeader*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetReportState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetReportState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetReportState*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetReportStateResponse_GetReportStateResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetReportStateResponse_GetReportStateResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetReportStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetReportStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetReportStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Login*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__LoginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__LoginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__LoginResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncPatientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncPatientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncPatientInfo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncPatientInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncPatientInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncPatientInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdatePatientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdatePatientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdatePatientInfo*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdatePatientInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdatePatientInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdatePatientInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncDataState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncDataState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncDataState*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncDataStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncDataStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncDataStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateDataState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateDataState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateDataState*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateDataStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateDataStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateDataStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncReportState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncReportState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncReportState*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__SyncReportStateResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__SyncReportStateResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__SyncReportStateResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UploadFile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UploadFile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UploadFile*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UploadFileResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UploadFileResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UploadFileResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetQuery:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetQuery*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetQuery*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetQueryResponse_GetQueryResult*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetQueryResponse_GetQueryResult*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetQueryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetQueryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetQueryResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateQuery:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateQuery*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateQuery*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__UpdateQueryResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__UpdateQueryResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__UpdateQueryResponse*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
	case SOAP_TYPE___ns1__GetReportState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetReportState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetReportState*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Login:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncPatientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncPatientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncPatientInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdatePatientInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdatePatientInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdatePatientInfo*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncDataState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncDataState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncDataState*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdateDataState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataState*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncReportState:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncReportState*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncReportState*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UploadFile:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UploadFile*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UploadFile*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetQuery:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetQuery*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetQuery*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdateQuery:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateQuery*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateQuery*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetReportState_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetReportState_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetReportState_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Login_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Login_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Login_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncPatientInfo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncPatientInfo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncPatientInfo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdatePatientInfo_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdatePatientInfo_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdatePatientInfo_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncDataState_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncDataState_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncDataState_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdateDataState_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateDataState_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateDataState_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__SyncReportState_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__SyncReportState_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__SyncReportState_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UploadFile_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UploadFile_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UploadFile_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetQuery_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetQuery_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetQuery_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__UpdateQuery_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__UpdateQuery_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__UpdateQuery_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetQueryResponse_GetQueryResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetQueryResponse_GetQueryResult::__any = NULL;
	this->_ns1__GetQueryResponse_GetQueryResult::__mixed = NULL;
}

void _ns1__GetQueryResponse_GetQueryResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetQueryResponse_GetQueryResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetQueryResponse_GetQueryResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetQueryResponse_GetQueryResult(struct soap *soap, const char *tag, int id, const _ns1__GetQueryResponse_GetQueryResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->_ns1__GetQueryResponse_GetQueryResult::__any), NULL);
	soap_outliteral(soap, "-mixed", &(a->_ns1__GetQueryResponse_GetQueryResult::__mixed), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetQueryResponse_GetQueryResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetQueryResponse_GetQueryResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetQueryResponse_GetQueryResult * SOAP_FMAC4 soap_in__ns1__GetQueryResponse_GetQueryResult(struct soap *soap, const char *tag, _ns1__GetQueryResponse_GetQueryResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetQueryResponse_GetQueryResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult, sizeof(_ns1__GetQueryResponse_GetQueryResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetQueryResponse_GetQueryResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->_ns1__GetQueryResponse_GetQueryResult::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->_ns1__GetQueryResponse_GetQueryResult::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetQueryResponse_GetQueryResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult, 0, sizeof(_ns1__GetQueryResponse_GetQueryResult), 0, soap_copy__ns1__GetQueryResponse_GetQueryResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetQueryResponse_GetQueryResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult);
	if (this->soap_out(soap, tag?tag:"ns1:GetQueryResponse-GetQueryResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetQueryResponse_GetQueryResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetQueryResponse_GetQueryResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetQueryResponse_GetQueryResult * SOAP_FMAC4 soap_get__ns1__GetQueryResponse_GetQueryResult(struct soap *soap, _ns1__GetQueryResponse_GetQueryResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetQueryResponse_GetQueryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetQueryResponse_GetQueryResult * SOAP_FMAC2 soap_instantiate__ns1__GetQueryResponse_GetQueryResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetQueryResponse_GetQueryResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetQueryResponse_GetQueryResult);
		if (size)
			*size = sizeof(_ns1__GetQueryResponse_GetQueryResult);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetQueryResponse_GetQueryResult, n);
		if (size)
			*size = n * sizeof(_ns1__GetQueryResponse_GetQueryResult);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetQueryResponse_GetQueryResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetQueryResponse_GetQueryResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetQueryResponse_GetQueryResult %p -> %p\n", q, p));
	*(_ns1__GetQueryResponse_GetQueryResult*)p = *(_ns1__GetQueryResponse_GetQueryResult*)q;
}

void _ns1__GetReportStateResponse_GetReportStateResult::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns1__GetReportStateResponse_GetReportStateResult::__any = NULL;
	this->_ns1__GetReportStateResponse_GetReportStateResult::__mixed = NULL;
}

void _ns1__GetReportStateResponse_GetReportStateResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetReportStateResponse_GetReportStateResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReportStateResponse_GetReportStateResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, const char *tag, int id, const _ns1__GetReportStateResponse_GetReportStateResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->_ns1__GetReportStateResponse_GetReportStateResult::__any), NULL);
	soap_outliteral(soap, "-mixed", &(a->_ns1__GetReportStateResponse_GetReportStateResult::__mixed), NULL);
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReportStateResponse_GetReportStateResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReportStateResponse_GetReportStateResult(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReportStateResponse_GetReportStateResult * SOAP_FMAC4 soap_in__ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, const char *tag, _ns1__GetReportStateResponse_GetReportStateResult *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReportStateResponse_GetReportStateResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult, sizeof(_ns1__GetReportStateResponse_GetReportStateResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReportStateResponse_GetReportStateResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->_ns1__GetReportStateResponse_GetReportStateResult::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->_ns1__GetReportStateResponse_GetReportStateResult::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReportStateResponse_GetReportStateResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult, 0, sizeof(_ns1__GetReportStateResponse_GetReportStateResult), 0, soap_copy__ns1__GetReportStateResponse_GetReportStateResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReportStateResponse_GetReportStateResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult);
	if (this->soap_out(soap, tag?tag:"ns1:GetReportStateResponse-GetReportStateResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReportStateResponse_GetReportStateResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReportStateResponse_GetReportStateResult(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReportStateResponse_GetReportStateResult * SOAP_FMAC4 soap_get__ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, _ns1__GetReportStateResponse_GetReportStateResult *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReportStateResponse_GetReportStateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReportStateResponse_GetReportStateResult * SOAP_FMAC2 soap_instantiate__ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReportStateResponse_GetReportStateResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetReportStateResponse_GetReportStateResult);
		if (size)
			*size = sizeof(_ns1__GetReportStateResponse_GetReportStateResult);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetReportStateResponse_GetReportStateResult, n);
		if (size)
			*size = n * sizeof(_ns1__GetReportStateResponse_GetReportStateResult);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetReportStateResponse_GetReportStateResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReportStateResponse_GetReportStateResult %p -> %p\n", q, p));
	*(_ns1__GetReportStateResponse_GetReportStateResult*)p = *(_ns1__GetReportStateResponse_GetReportStateResult*)q;
}

void _ns1__UpdateQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__UpdateQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	/* transient soap skipped */
#endif
}

int _ns1__UpdateQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateQueryResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateQueryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateQueryResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateQueryResponse * SOAP_FMAC4 soap_in__ns1__UpdateQueryResponse(struct soap *soap, const char *tag, _ns1__UpdateQueryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateQueryResponse, sizeof(_ns1__UpdateQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateQueryResponse, 0, sizeof(_ns1__UpdateQueryResponse), 0, soap_copy__ns1__UpdateQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdateQueryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateQueryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateQueryResponse * SOAP_FMAC4 soap_get__ns1__UpdateQueryResponse(struct soap *soap, _ns1__UpdateQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateQueryResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateQueryResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdateQueryResponse);
		if (size)
			*size = sizeof(_ns1__UpdateQueryResponse);
		((_ns1__UpdateQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdateQueryResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateQueryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateQueryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateQueryResponse %p -> %p\n", q, p));
	*(_ns1__UpdateQueryResponse*)p = *(_ns1__UpdateQueryResponse*)q;
}

void _ns1__UpdateQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateQuery::sql);
	/* transient soap skipped */
}

void _ns1__UpdateQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UpdateQuery::sql);
	/* transient soap skipped */
#endif
}

int _ns1__UpdateQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateQuery(struct soap *soap, const char *tag, int id, const _ns1__UpdateQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateQuery), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, &(a->_ns1__UpdateQuery::sql), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateQuery * SOAP_FMAC4 soap_in__ns1__UpdateQuery(struct soap *soap, const char *tag, _ns1__UpdateQuery *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateQuery, sizeof(_ns1__UpdateQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sql1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sql", &(a->_ns1__UpdateQuery::sql), "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateQuery, 0, sizeof(_ns1__UpdateQuery), 0, soap_copy__ns1__UpdateQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdateQuery);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateQuery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateQuery * SOAP_FMAC4 soap_get__ns1__UpdateQuery(struct soap *soap, _ns1__UpdateQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateQuery * SOAP_FMAC2 soap_instantiate__ns1__UpdateQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateQuery, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdateQuery);
		if (size)
			*size = sizeof(_ns1__UpdateQuery);
		((_ns1__UpdateQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdateQuery, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateQuery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateQuery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateQuery %p -> %p\n", q, p));
	*(_ns1__UpdateQuery*)p = *(_ns1__UpdateQuery*)q;
}

void _ns1__GetQueryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetQueryResponse::GetQueryResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetQueryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, &this->_ns1__GetQueryResponse::GetQueryResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetQueryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetQueryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetQueryResponse(struct soap *soap, const char *tag, int id, const _ns1__GetQueryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetQueryResponse), type))
		return soap->error;
	if (a->GetQueryResult)
		soap_element_result(soap, "ns1:GetQueryResult");
	if (soap_out_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, "ns1:GetQueryResult", -1, &(a->_ns1__GetQueryResponse::GetQueryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetQueryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetQueryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetQueryResponse * SOAP_FMAC4 soap_in__ns1__GetQueryResponse(struct soap *soap, const char *tag, _ns1__GetQueryResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetQueryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetQueryResponse, sizeof(_ns1__GetQueryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetQueryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetQueryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetQueryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetQueryResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, "ns1:GetQueryResult", &(a->_ns1__GetQueryResponse::GetQueryResult), ""))
				{	soap_flag_GetQueryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetQueryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetQueryResponse, 0, sizeof(_ns1__GetQueryResponse), 0, soap_copy__ns1__GetQueryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetQueryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetQueryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetQueryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetQueryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetQueryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetQueryResponse * SOAP_FMAC4 soap_get__ns1__GetQueryResponse(struct soap *soap, _ns1__GetQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetQueryResponse * SOAP_FMAC2 soap_instantiate__ns1__GetQueryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetQueryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetQueryResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetQueryResponse);
		if (size)
			*size = sizeof(_ns1__GetQueryResponse);
		((_ns1__GetQueryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetQueryResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetQueryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetQueryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetQueryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetQueryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetQueryResponse %p -> %p\n", q, p));
	*(_ns1__GetQueryResponse*)p = *(_ns1__GetQueryResponse*)q;
}

void _ns1__GetQuery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetQuery::sql);
	/* transient soap skipped */
}

void _ns1__GetQuery::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__GetQuery::sql);
	/* transient soap skipped */
#endif
}

int _ns1__GetQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetQuery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetQuery(struct soap *soap, const char *tag, int id, const _ns1__GetQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetQuery), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sql", -1, &(a->_ns1__GetQuery::sql), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetQuery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetQuery * SOAP_FMAC4 soap_in__ns1__GetQuery(struct soap *soap, const char *tag, _ns1__GetQuery *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetQuery, sizeof(_ns1__GetQuery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetQuery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetQuery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sql1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sql", &(a->_ns1__GetQuery::sql), "xsd:string"))
				{	soap_flag_sql1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetQuery, 0, sizeof(_ns1__GetQuery), 0, soap_copy__ns1__GetQuery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetQuery);
	if (this->soap_out(soap, tag?tag:"ns1:GetQuery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetQuery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetQuery * SOAP_FMAC4 soap_get__ns1__GetQuery(struct soap *soap, _ns1__GetQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetQuery * SOAP_FMAC2 soap_instantiate__ns1__GetQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetQuery, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetQuery);
		if (size)
			*size = sizeof(_ns1__GetQuery);
		((_ns1__GetQuery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetQuery, n);
		if (size)
			*size = n * sizeof(_ns1__GetQuery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetQuery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetQuery %p -> %p\n", q, p));
	*(_ns1__GetQuery*)p = *(_ns1__GetQuery*)q;
}

void _ns1__UploadFileResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UploadFileResponse::UploadFileResult);
	/* transient soap skipped */
}

void _ns1__UploadFileResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UploadFileResponse::UploadFileResult);
	/* transient soap skipped */
#endif
}

int _ns1__UploadFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadFileResponse(struct soap *soap, const char *tag, int id, const _ns1__UploadFileResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadFileResponse), type))
		return soap->error;
	if (a->UploadFileResult)
		soap_element_result(soap, "ns1:UploadFileResult");
	if (soap_out_string(soap, "ns1:UploadFileResult", -1, &(a->_ns1__UploadFileResponse::UploadFileResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadFileResponse * SOAP_FMAC4 soap_in__ns1__UploadFileResponse(struct soap *soap, const char *tag, _ns1__UploadFileResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadFileResponse, sizeof(_ns1__UploadFileResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadFileResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadFileResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadFileResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadFileResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UploadFileResult", &(a->_ns1__UploadFileResponse::UploadFileResult), "xsd:string"))
				{	soap_flag_UploadFileResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UploadFileResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadFileResponse, 0, sizeof(_ns1__UploadFileResponse), 0, soap_copy__ns1__UploadFileResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UploadFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadFileResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UploadFileResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadFileResponse * SOAP_FMAC4 soap_get__ns1__UploadFileResponse(struct soap *soap, _ns1__UploadFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadFileResponse * SOAP_FMAC2 soap_instantiate__ns1__UploadFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadFileResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UploadFileResponse);
		if (size)
			*size = sizeof(_ns1__UploadFileResponse);
		((_ns1__UploadFileResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UploadFileResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UploadFileResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadFileResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadFileResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadFileResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadFileResponse %p -> %p\n", q, p));
	*(_ns1__UploadFileResponse*)p = *(_ns1__UploadFileResponse*)q;
}

void _ns1__UploadFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UploadFile::persondataid);
	soap_default_string(soap, &this->_ns1__UploadFile::sFileName);
	this->_ns1__UploadFile::pFileContent = NULL;
	/* transient soap skipped */
}

void _ns1__UploadFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UploadFile::persondataid);
	soap_serialize_string(soap, &this->_ns1__UploadFile::sFileName);
	soap_serialize_PointerToxsd__base64Binary(soap, &this->_ns1__UploadFile::pFileContent);
	/* transient soap skipped */
#endif
}

int _ns1__UploadFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UploadFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UploadFile(struct soap *soap, const char *tag, int id, const _ns1__UploadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UploadFile), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:persondataid", -1, &(a->_ns1__UploadFile::persondataid), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sFileName", -1, &(a->_ns1__UploadFile::sFileName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "ns1:pFileContent", -1, &(a->_ns1__UploadFile::pFileContent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UploadFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UploadFile(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UploadFile * SOAP_FMAC4 soap_in__ns1__UploadFile(struct soap *soap, const char *tag, _ns1__UploadFile *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UploadFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UploadFile, sizeof(_ns1__UploadFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UploadFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UploadFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_persondataid1 = 1;
	size_t soap_flag_sFileName1 = 1;
	size_t soap_flag_pFileContent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_persondataid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:persondataid", &(a->_ns1__UploadFile::persondataid), "xsd:string"))
				{	soap_flag_persondataid1--;
					continue;
				}
			if (soap_flag_sFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sFileName", &(a->_ns1__UploadFile::sFileName), "xsd:string"))
				{	soap_flag_sFileName1--;
					continue;
				}
			if (soap_flag_pFileContent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "ns1:pFileContent", &(a->_ns1__UploadFile::pFileContent), "xsd:base64Binary"))
				{	soap_flag_pFileContent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UploadFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UploadFile, 0, sizeof(_ns1__UploadFile), 0, soap_copy__ns1__UploadFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UploadFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UploadFile);
	if (this->soap_out(soap, tag?tag:"ns1:UploadFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UploadFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UploadFile(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UploadFile * SOAP_FMAC4 soap_get__ns1__UploadFile(struct soap *soap, _ns1__UploadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UploadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UploadFile * SOAP_FMAC2 soap_instantiate__ns1__UploadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UploadFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UploadFile, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UploadFile);
		if (size)
			*size = sizeof(_ns1__UploadFile);
		((_ns1__UploadFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UploadFile, n);
		if (size)
			*size = n * sizeof(_ns1__UploadFile);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UploadFile*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UploadFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UploadFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UploadFile %p -> %p\n", q, p));
	*(_ns1__UploadFile*)p = *(_ns1__UploadFile*)q;
}

void _ns1__SyncReportStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncReportStateResponse::SyncReportStateResult);
	/* transient soap skipped */
}

void _ns1__SyncReportStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncReportStateResponse::SyncReportStateResult);
	/* transient soap skipped */
#endif
}

int _ns1__SyncReportStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncReportStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncReportStateResponse(struct soap *soap, const char *tag, int id, const _ns1__SyncReportStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncReportStateResponse), type))
		return soap->error;
	if (a->SyncReportStateResult)
		soap_element_result(soap, "ns1:SyncReportStateResult");
	if (soap_out_string(soap, "ns1:SyncReportStateResult", -1, &(a->_ns1__SyncReportStateResponse::SyncReportStateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncReportStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncReportStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncReportStateResponse * SOAP_FMAC4 soap_in__ns1__SyncReportStateResponse(struct soap *soap, const char *tag, _ns1__SyncReportStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncReportStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncReportStateResponse, sizeof(_ns1__SyncReportStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncReportStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncReportStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SyncReportStateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SyncReportStateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SyncReportStateResult", &(a->_ns1__SyncReportStateResponse::SyncReportStateResult), "xsd:string"))
				{	soap_flag_SyncReportStateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SyncReportStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncReportStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncReportStateResponse, 0, sizeof(_ns1__SyncReportStateResponse), 0, soap_copy__ns1__SyncReportStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncReportStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncReportStateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SyncReportStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncReportStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncReportStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncReportStateResponse * SOAP_FMAC4 soap_get__ns1__SyncReportStateResponse(struct soap *soap, _ns1__SyncReportStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncReportStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncReportStateResponse * SOAP_FMAC2 soap_instantiate__ns1__SyncReportStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncReportStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncReportStateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncReportStateResponse);
		if (size)
			*size = sizeof(_ns1__SyncReportStateResponse);
		((_ns1__SyncReportStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncReportStateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SyncReportStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncReportStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncReportStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncReportStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncReportStateResponse %p -> %p\n", q, p));
	*(_ns1__SyncReportStateResponse*)p = *(_ns1__SyncReportStateResponse*)q;
}

void _ns1__SyncReportState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncReportState::nCheckStationID);
	soap_default_string(soap, &this->_ns1__SyncReportState::starthandledtm);
	soap_default_string(soap, &this->_ns1__SyncReportState::endhandledtm);
	soap_default_string(soap, &this->_ns1__SyncReportState::reportcollectdtm);
	/* transient soap skipped */
}

void _ns1__SyncReportState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncReportState::nCheckStationID);
	soap_serialize_string(soap, &this->_ns1__SyncReportState::starthandledtm);
	soap_serialize_string(soap, &this->_ns1__SyncReportState::endhandledtm);
	soap_serialize_string(soap, &this->_ns1__SyncReportState::reportcollectdtm);
	/* transient soap skipped */
#endif
}

int _ns1__SyncReportState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncReportState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncReportState(struct soap *soap, const char *tag, int id, const _ns1__SyncReportState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncReportState), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nCheckStationID", -1, &(a->_ns1__SyncReportState::nCheckStationID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:starthandledtm", -1, &(a->_ns1__SyncReportState::starthandledtm), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:endhandledtm", -1, &(a->_ns1__SyncReportState::endhandledtm), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:reportcollectdtm", -1, &(a->_ns1__SyncReportState::reportcollectdtm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncReportState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncReportState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncReportState * SOAP_FMAC4 soap_in__ns1__SyncReportState(struct soap *soap, const char *tag, _ns1__SyncReportState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncReportState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncReportState, sizeof(_ns1__SyncReportState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncReportState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncReportState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nCheckStationID1 = 1;
	size_t soap_flag_starthandledtm1 = 1;
	size_t soap_flag_endhandledtm1 = 1;
	size_t soap_flag_reportcollectdtm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nCheckStationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nCheckStationID", &(a->_ns1__SyncReportState::nCheckStationID), "xsd:string"))
				{	soap_flag_nCheckStationID1--;
					continue;
				}
			if (soap_flag_starthandledtm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:starthandledtm", &(a->_ns1__SyncReportState::starthandledtm), "xsd:string"))
				{	soap_flag_starthandledtm1--;
					continue;
				}
			if (soap_flag_endhandledtm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:endhandledtm", &(a->_ns1__SyncReportState::endhandledtm), "xsd:string"))
				{	soap_flag_endhandledtm1--;
					continue;
				}
			if (soap_flag_reportcollectdtm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:reportcollectdtm", &(a->_ns1__SyncReportState::reportcollectdtm), "xsd:string"))
				{	soap_flag_reportcollectdtm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncReportState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncReportState, 0, sizeof(_ns1__SyncReportState), 0, soap_copy__ns1__SyncReportState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncReportState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncReportState);
	if (this->soap_out(soap, tag?tag:"ns1:SyncReportState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncReportState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncReportState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncReportState * SOAP_FMAC4 soap_get__ns1__SyncReportState(struct soap *soap, _ns1__SyncReportState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncReportState * SOAP_FMAC2 soap_instantiate__ns1__SyncReportState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncReportState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncReportState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncReportState);
		if (size)
			*size = sizeof(_ns1__SyncReportState);
		((_ns1__SyncReportState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncReportState, n);
		if (size)
			*size = n * sizeof(_ns1__SyncReportState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncReportState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncReportState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncReportState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncReportState %p -> %p\n", q, p));
	*(_ns1__SyncReportState*)p = *(_ns1__SyncReportState*)q;
}

void _ns1__UpdateDataStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDataStateResponse::UpdateDataStateResult);
	/* transient soap skipped */
}

void _ns1__UpdateDataStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UpdateDataStateResponse::UpdateDataStateResult);
	/* transient soap skipped */
#endif
}

int _ns1__UpdateDataStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDataStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDataStateResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateDataStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDataStateResponse), type))
		return soap->error;
	if (a->UpdateDataStateResult)
		soap_element_result(soap, "ns1:UpdateDataStateResult");
	if (soap_out_string(soap, "ns1:UpdateDataStateResult", -1, &(a->_ns1__UpdateDataStateResponse::UpdateDataStateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDataStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDataStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDataStateResponse * SOAP_FMAC4 soap_in__ns1__UpdateDataStateResponse(struct soap *soap, const char *tag, _ns1__UpdateDataStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDataStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDataStateResponse, sizeof(_ns1__UpdateDataStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDataStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDataStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateDataStateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateDataStateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateDataStateResult", &(a->_ns1__UpdateDataStateResponse::UpdateDataStateResult), "xsd:string"))
				{	soap_flag_UpdateDataStateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateDataStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDataStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDataStateResponse, 0, sizeof(_ns1__UpdateDataStateResponse), 0, soap_copy__ns1__UpdateDataStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateDataStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdateDataStateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDataStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDataStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDataStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDataStateResponse * SOAP_FMAC4 soap_get__ns1__UpdateDataStateResponse(struct soap *soap, _ns1__UpdateDataStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDataStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDataStateResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDataStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDataStateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdateDataStateResponse);
		if (size)
			*size = sizeof(_ns1__UpdateDataStateResponse);
		((_ns1__UpdateDataStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdateDataStateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateDataStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateDataStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateDataStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDataStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDataStateResponse %p -> %p\n", q, p));
	*(_ns1__UpdateDataStateResponse*)p = *(_ns1__UpdateDataStateResponse*)q;
}

void _ns1__UpdateDataState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateDataState::nPersondataid);
	soap_default_string(soap, &this->_ns1__UpdateDataState::sFileName);
	soap_default_string(soap, &this->_ns1__UpdateDataState::sFileDesc);
	soap_default_string(soap, &this->_ns1__UpdateDataState::sOccurDtm);
	soap_default_string(soap, &this->_ns1__UpdateDataState::lFileLength);
	soap_default_string(soap, &this->_ns1__UpdateDataState::lDataFrom);
	/* transient soap skipped */
}

void _ns1__UpdateDataState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::nPersondataid);
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::sFileName);
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::sFileDesc);
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::sOccurDtm);
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::lFileLength);
	soap_serialize_string(soap, &this->_ns1__UpdateDataState::lDataFrom);
	/* transient soap skipped */
#endif
}

int _ns1__UpdateDataState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateDataState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateDataState(struct soap *soap, const char *tag, int id, const _ns1__UpdateDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateDataState), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nPersondataid", -1, &(a->_ns1__UpdateDataState::nPersondataid), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sFileName", -1, &(a->_ns1__UpdateDataState::sFileName), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sFileDesc", -1, &(a->_ns1__UpdateDataState::sFileDesc), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sOccurDtm", -1, &(a->_ns1__UpdateDataState::sOccurDtm), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:lFileLength", -1, &(a->_ns1__UpdateDataState::lFileLength), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:lDataFrom", -1, &(a->_ns1__UpdateDataState::lDataFrom), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateDataState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateDataState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateDataState * SOAP_FMAC4 soap_in__ns1__UpdateDataState(struct soap *soap, const char *tag, _ns1__UpdateDataState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateDataState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateDataState, sizeof(_ns1__UpdateDataState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateDataState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateDataState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nPersondataid1 = 1;
	size_t soap_flag_sFileName1 = 1;
	size_t soap_flag_sFileDesc1 = 1;
	size_t soap_flag_sOccurDtm1 = 1;
	size_t soap_flag_lFileLength1 = 1;
	size_t soap_flag_lDataFrom1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nPersondataid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nPersondataid", &(a->_ns1__UpdateDataState::nPersondataid), "xsd:string"))
				{	soap_flag_nPersondataid1--;
					continue;
				}
			if (soap_flag_sFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sFileName", &(a->_ns1__UpdateDataState::sFileName), "xsd:string"))
				{	soap_flag_sFileName1--;
					continue;
				}
			if (soap_flag_sFileDesc1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sFileDesc", &(a->_ns1__UpdateDataState::sFileDesc), "xsd:string"))
				{	soap_flag_sFileDesc1--;
					continue;
				}
			if (soap_flag_sOccurDtm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sOccurDtm", &(a->_ns1__UpdateDataState::sOccurDtm), "xsd:string"))
				{	soap_flag_sOccurDtm1--;
					continue;
				}
			if (soap_flag_lFileLength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:lFileLength", &(a->_ns1__UpdateDataState::lFileLength), "xsd:string"))
				{	soap_flag_lFileLength1--;
					continue;
				}
			if (soap_flag_lDataFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:lDataFrom", &(a->_ns1__UpdateDataState::lDataFrom), "xsd:string"))
				{	soap_flag_lDataFrom1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateDataState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateDataState, 0, sizeof(_ns1__UpdateDataState), 0, soap_copy__ns1__UpdateDataState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateDataState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdateDataState);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateDataState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateDataState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateDataState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateDataState * SOAP_FMAC4 soap_get__ns1__UpdateDataState(struct soap *soap, _ns1__UpdateDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateDataState * SOAP_FMAC2 soap_instantiate__ns1__UpdateDataState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateDataState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateDataState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdateDataState);
		if (size)
			*size = sizeof(_ns1__UpdateDataState);
		((_ns1__UpdateDataState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdateDataState, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateDataState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateDataState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateDataState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateDataState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateDataState %p -> %p\n", q, p));
	*(_ns1__UpdateDataState*)p = *(_ns1__UpdateDataState*)q;
}

void _ns1__SyncDataStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncDataStateResponse::SyncDataStateResult);
	/* transient soap skipped */
}

void _ns1__SyncDataStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncDataStateResponse::SyncDataStateResult);
	/* transient soap skipped */
#endif
}

int _ns1__SyncDataStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncDataStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncDataStateResponse(struct soap *soap, const char *tag, int id, const _ns1__SyncDataStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncDataStateResponse), type))
		return soap->error;
	if (a->SyncDataStateResult)
		soap_element_result(soap, "ns1:SyncDataStateResult");
	if (soap_out_string(soap, "ns1:SyncDataStateResult", -1, &(a->_ns1__SyncDataStateResponse::SyncDataStateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncDataStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncDataStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncDataStateResponse * SOAP_FMAC4 soap_in__ns1__SyncDataStateResponse(struct soap *soap, const char *tag, _ns1__SyncDataStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncDataStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncDataStateResponse, sizeof(_ns1__SyncDataStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncDataStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncDataStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SyncDataStateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SyncDataStateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SyncDataStateResult", &(a->_ns1__SyncDataStateResponse::SyncDataStateResult), "xsd:string"))
				{	soap_flag_SyncDataStateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SyncDataStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncDataStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncDataStateResponse, 0, sizeof(_ns1__SyncDataStateResponse), 0, soap_copy__ns1__SyncDataStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncDataStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncDataStateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SyncDataStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncDataStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncDataStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncDataStateResponse * SOAP_FMAC4 soap_get__ns1__SyncDataStateResponse(struct soap *soap, _ns1__SyncDataStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncDataStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncDataStateResponse * SOAP_FMAC2 soap_instantiate__ns1__SyncDataStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncDataStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncDataStateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncDataStateResponse);
		if (size)
			*size = sizeof(_ns1__SyncDataStateResponse);
		((_ns1__SyncDataStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncDataStateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SyncDataStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncDataStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncDataStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncDataStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncDataStateResponse %p -> %p\n", q, p));
	*(_ns1__SyncDataStateResponse*)p = *(_ns1__SyncDataStateResponse*)q;
}

void _ns1__SyncDataState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncDataState::nCheckStationID);
	soap_default_string(soap, &this->_ns1__SyncDataState::sDatetime);
	/* transient soap skipped */
}

void _ns1__SyncDataState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncDataState::nCheckStationID);
	soap_serialize_string(soap, &this->_ns1__SyncDataState::sDatetime);
	/* transient soap skipped */
#endif
}

int _ns1__SyncDataState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncDataState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncDataState(struct soap *soap, const char *tag, int id, const _ns1__SyncDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncDataState), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nCheckStationID", -1, &(a->_ns1__SyncDataState::nCheckStationID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sDatetime", -1, &(a->_ns1__SyncDataState::sDatetime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncDataState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncDataState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncDataState * SOAP_FMAC4 soap_in__ns1__SyncDataState(struct soap *soap, const char *tag, _ns1__SyncDataState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncDataState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncDataState, sizeof(_ns1__SyncDataState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncDataState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncDataState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nCheckStationID1 = 1;
	size_t soap_flag_sDatetime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nCheckStationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nCheckStationID", &(a->_ns1__SyncDataState::nCheckStationID), "xsd:string"))
				{	soap_flag_nCheckStationID1--;
					continue;
				}
			if (soap_flag_sDatetime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sDatetime", &(a->_ns1__SyncDataState::sDatetime), "xsd:string"))
				{	soap_flag_sDatetime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncDataState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncDataState, 0, sizeof(_ns1__SyncDataState), 0, soap_copy__ns1__SyncDataState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncDataState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncDataState);
	if (this->soap_out(soap, tag?tag:"ns1:SyncDataState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncDataState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncDataState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncDataState * SOAP_FMAC4 soap_get__ns1__SyncDataState(struct soap *soap, _ns1__SyncDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncDataState * SOAP_FMAC2 soap_instantiate__ns1__SyncDataState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncDataState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncDataState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncDataState);
		if (size)
			*size = sizeof(_ns1__SyncDataState);
		((_ns1__SyncDataState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncDataState, n);
		if (size)
			*size = n * sizeof(_ns1__SyncDataState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncDataState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncDataState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncDataState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncDataState %p -> %p\n", q, p));
	*(_ns1__SyncDataState*)p = *(_ns1__SyncDataState*)q;
}

void _ns1__UpdatePatientInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePatientInfoResponse::UpdatePatientInfoResult);
	/* transient soap skipped */
}

void _ns1__UpdatePatientInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UpdatePatientInfoResponse::UpdatePatientInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__UpdatePatientInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePatientInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePatientInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdatePatientInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePatientInfoResponse), type))
		return soap->error;
	if (a->UpdatePatientInfoResult)
		soap_element_result(soap, "ns1:UpdatePatientInfoResult");
	if (soap_out_string(soap, "ns1:UpdatePatientInfoResult", -1, &(a->_ns1__UpdatePatientInfoResponse::UpdatePatientInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePatientInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePatientInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePatientInfoResponse * SOAP_FMAC4 soap_in__ns1__UpdatePatientInfoResponse(struct soap *soap, const char *tag, _ns1__UpdatePatientInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePatientInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePatientInfoResponse, sizeof(_ns1__UpdatePatientInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePatientInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePatientInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdatePatientInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdatePatientInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdatePatientInfoResult", &(a->_ns1__UpdatePatientInfoResponse::UpdatePatientInfoResult), "xsd:string"))
				{	soap_flag_UpdatePatientInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdatePatientInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePatientInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePatientInfoResponse, 0, sizeof(_ns1__UpdatePatientInfoResponse), 0, soap_copy__ns1__UpdatePatientInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePatientInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdatePatientInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePatientInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePatientInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePatientInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePatientInfoResponse * SOAP_FMAC4 soap_get__ns1__UpdatePatientInfoResponse(struct soap *soap, _ns1__UpdatePatientInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePatientInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePatientInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePatientInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePatientInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePatientInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdatePatientInfoResponse);
		if (size)
			*size = sizeof(_ns1__UpdatePatientInfoResponse);
		((_ns1__UpdatePatientInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdatePatientInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdatePatientInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePatientInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdatePatientInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePatientInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePatientInfoResponse %p -> %p\n", q, p));
	*(_ns1__UpdatePatientInfoResponse*)p = *(_ns1__UpdatePatientInfoResponse*)q;
}

void _ns1__UpdatePatientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePatientInfo::sAccount);
	soap_default_string(soap, &this->_ns1__UpdatePatientInfo::sjsonPatientInfo);
	/* transient soap skipped */
}

void _ns1__UpdatePatientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__UpdatePatientInfo::sAccount);
	soap_serialize_string(soap, &this->_ns1__UpdatePatientInfo::sjsonPatientInfo);
	/* transient soap skipped */
#endif
}

int _ns1__UpdatePatientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePatientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePatientInfo(struct soap *soap, const char *tag, int id, const _ns1__UpdatePatientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePatientInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sAccount", -1, &(a->_ns1__UpdatePatientInfo::sAccount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sjsonPatientInfo", -1, &(a->_ns1__UpdatePatientInfo::sjsonPatientInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePatientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePatientInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePatientInfo * SOAP_FMAC4 soap_in__ns1__UpdatePatientInfo(struct soap *soap, const char *tag, _ns1__UpdatePatientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePatientInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePatientInfo, sizeof(_ns1__UpdatePatientInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePatientInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePatientInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sAccount1 = 1;
	size_t soap_flag_sjsonPatientInfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sAccount", &(a->_ns1__UpdatePatientInfo::sAccount), "xsd:string"))
				{	soap_flag_sAccount1--;
					continue;
				}
			if (soap_flag_sjsonPatientInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sjsonPatientInfo", &(a->_ns1__UpdatePatientInfo::sjsonPatientInfo), "xsd:string"))
				{	soap_flag_sjsonPatientInfo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePatientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePatientInfo, 0, sizeof(_ns1__UpdatePatientInfo), 0, soap_copy__ns1__UpdatePatientInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePatientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__UpdatePatientInfo);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePatientInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePatientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePatientInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePatientInfo * SOAP_FMAC4 soap_get__ns1__UpdatePatientInfo(struct soap *soap, _ns1__UpdatePatientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePatientInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdatePatientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePatientInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePatientInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__UpdatePatientInfo);
		if (size)
			*size = sizeof(_ns1__UpdatePatientInfo);
		((_ns1__UpdatePatientInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__UpdatePatientInfo, n);
		if (size)
			*size = n * sizeof(_ns1__UpdatePatientInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePatientInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdatePatientInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePatientInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePatientInfo %p -> %p\n", q, p));
	*(_ns1__UpdatePatientInfo*)p = *(_ns1__UpdatePatientInfo*)q;
}

void _ns1__SyncPatientInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncPatientInfoResponse::SyncPatientInfoResult);
	/* transient soap skipped */
}

void _ns1__SyncPatientInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncPatientInfoResponse::SyncPatientInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__SyncPatientInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncPatientInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncPatientInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__SyncPatientInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncPatientInfoResponse), type))
		return soap->error;
	if (a->SyncPatientInfoResult)
		soap_element_result(soap, "ns1:SyncPatientInfoResult");
	if (soap_out_string(soap, "ns1:SyncPatientInfoResult", -1, &(a->_ns1__SyncPatientInfoResponse::SyncPatientInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncPatientInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncPatientInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncPatientInfoResponse * SOAP_FMAC4 soap_in__ns1__SyncPatientInfoResponse(struct soap *soap, const char *tag, _ns1__SyncPatientInfoResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncPatientInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncPatientInfoResponse, sizeof(_ns1__SyncPatientInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncPatientInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncPatientInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SyncPatientInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SyncPatientInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:SyncPatientInfoResult", &(a->_ns1__SyncPatientInfoResponse::SyncPatientInfoResult), "xsd:string"))
				{	soap_flag_SyncPatientInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:SyncPatientInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncPatientInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncPatientInfoResponse, 0, sizeof(_ns1__SyncPatientInfoResponse), 0, soap_copy__ns1__SyncPatientInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncPatientInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncPatientInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:SyncPatientInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncPatientInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncPatientInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncPatientInfoResponse * SOAP_FMAC4 soap_get__ns1__SyncPatientInfoResponse(struct soap *soap, _ns1__SyncPatientInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncPatientInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncPatientInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__SyncPatientInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncPatientInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncPatientInfoResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncPatientInfoResponse);
		if (size)
			*size = sizeof(_ns1__SyncPatientInfoResponse);
		((_ns1__SyncPatientInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncPatientInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__SyncPatientInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncPatientInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncPatientInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncPatientInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncPatientInfoResponse %p -> %p\n", q, p));
	*(_ns1__SyncPatientInfoResponse*)p = *(_ns1__SyncPatientInfoResponse*)q;
}

void _ns1__SyncPatientInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__SyncPatientInfo::nCheckStationID);
	soap_default_string(soap, &this->_ns1__SyncPatientInfo::sDatetime);
	/* transient soap skipped */
}

void _ns1__SyncPatientInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__SyncPatientInfo::nCheckStationID);
	soap_serialize_string(soap, &this->_ns1__SyncPatientInfo::sDatetime);
	/* transient soap skipped */
#endif
}

int _ns1__SyncPatientInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__SyncPatientInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__SyncPatientInfo(struct soap *soap, const char *tag, int id, const _ns1__SyncPatientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__SyncPatientInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:nCheckStationID", -1, &(a->_ns1__SyncPatientInfo::nCheckStationID), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sDatetime", -1, &(a->_ns1__SyncPatientInfo::sDatetime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__SyncPatientInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__SyncPatientInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__SyncPatientInfo * SOAP_FMAC4 soap_in__ns1__SyncPatientInfo(struct soap *soap, const char *tag, _ns1__SyncPatientInfo *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__SyncPatientInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__SyncPatientInfo, sizeof(_ns1__SyncPatientInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__SyncPatientInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__SyncPatientInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nCheckStationID1 = 1;
	size_t soap_flag_sDatetime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nCheckStationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:nCheckStationID", &(a->_ns1__SyncPatientInfo::nCheckStationID), "xsd:string"))
				{	soap_flag_nCheckStationID1--;
					continue;
				}
			if (soap_flag_sDatetime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sDatetime", &(a->_ns1__SyncPatientInfo::sDatetime), "xsd:string"))
				{	soap_flag_sDatetime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__SyncPatientInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__SyncPatientInfo, 0, sizeof(_ns1__SyncPatientInfo), 0, soap_copy__ns1__SyncPatientInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__SyncPatientInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__SyncPatientInfo);
	if (this->soap_out(soap, tag?tag:"ns1:SyncPatientInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__SyncPatientInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__SyncPatientInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__SyncPatientInfo * SOAP_FMAC4 soap_get__ns1__SyncPatientInfo(struct soap *soap, _ns1__SyncPatientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__SyncPatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__SyncPatientInfo * SOAP_FMAC2 soap_instantiate__ns1__SyncPatientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__SyncPatientInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__SyncPatientInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__SyncPatientInfo);
		if (size)
			*size = sizeof(_ns1__SyncPatientInfo);
		((_ns1__SyncPatientInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__SyncPatientInfo, n);
		if (size)
			*size = n * sizeof(_ns1__SyncPatientInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__SyncPatientInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__SyncPatientInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__SyncPatientInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__SyncPatientInfo %p -> %p\n", q, p));
	*(_ns1__SyncPatientInfo*)p = *(_ns1__SyncPatientInfo*)q;
}

void _ns1__LoginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__LoginResponse::LoginResult);
	/* transient soap skipped */
}

void _ns1__LoginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__LoginResponse::LoginResult);
	/* transient soap skipped */
#endif
}

int _ns1__LoginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__LoginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__LoginResponse(struct soap *soap, const char *tag, int id, const _ns1__LoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__LoginResponse), type))
		return soap->error;
	if (a->LoginResult)
		soap_element_result(soap, "ns1:LoginResult");
	if (soap_out_string(soap, "ns1:LoginResult", -1, &(a->_ns1__LoginResponse::LoginResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__LoginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__LoginResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_in__ns1__LoginResponse(struct soap *soap, const char *tag, _ns1__LoginResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__LoginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__LoginResponse, sizeof(_ns1__LoginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__LoginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__LoginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_LoginResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LoginResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:LoginResult", &(a->_ns1__LoginResponse::LoginResult), "xsd:string"))
				{	soap_flag_LoginResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:LoginResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__LoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__LoginResponse, 0, sizeof(_ns1__LoginResponse), 0, soap_copy__ns1__LoginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__LoginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__LoginResponse);
	if (this->soap_out(soap, tag?tag:"ns1:LoginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__LoginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__LoginResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__LoginResponse * SOAP_FMAC4 soap_get__ns1__LoginResponse(struct soap *soap, _ns1__LoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__LoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__LoginResponse * SOAP_FMAC2 soap_instantiate__ns1__LoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__LoginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__LoginResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__LoginResponse);
		if (size)
			*size = sizeof(_ns1__LoginResponse);
		((_ns1__LoginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__LoginResponse, n);
		if (size)
			*size = n * sizeof(_ns1__LoginResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__LoginResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__LoginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__LoginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__LoginResponse %p -> %p\n", q, p));
	*(_ns1__LoginResponse*)p = *(_ns1__LoginResponse*)q;
}

void _ns1__Login::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__Login::sAccount);
	soap_default_string(soap, &this->_ns1__Login::sPassword);
	soap_default_string(soap, &this->_ns1__Login::softdtmpad);
	/* transient soap skipped */
}

void _ns1__Login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__Login::sAccount);
	soap_serialize_string(soap, &this->_ns1__Login::sPassword);
	soap_serialize_string(soap, &this->_ns1__Login::softdtmpad);
	/* transient soap skipped */
#endif
}

int _ns1__Login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Login(struct soap *soap, const char *tag, int id, const _ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Login), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sAccount", -1, &(a->_ns1__Login::sAccount), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sPassword", -1, &(a->_ns1__Login::sPassword), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:softdtmpad", -1, &(a->_ns1__Login::softdtmpad), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__Login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Login(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_in__ns1__Login(struct soap *soap, const char *tag, _ns1__Login *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Login, sizeof(_ns1__Login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__Login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__Login *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sAccount1 = 1;
	size_t soap_flag_sPassword1 = 1;
	size_t soap_flag_softdtmpad1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sAccount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sAccount", &(a->_ns1__Login::sAccount), "xsd:string"))
				{	soap_flag_sAccount1--;
					continue;
				}
			if (soap_flag_sPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sPassword", &(a->_ns1__Login::sPassword), "xsd:string"))
				{	soap_flag_sPassword1--;
					continue;
				}
			if (soap_flag_softdtmpad1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:softdtmpad", &(a->_ns1__Login::softdtmpad), "xsd:string"))
				{	soap_flag_softdtmpad1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__Login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Login, 0, sizeof(_ns1__Login), 0, soap_copy__ns1__Login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__Login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__Login);
	if (this->soap_out(soap, tag?tag:"ns1:Login", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Login(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Login * SOAP_FMAC4 soap_get__ns1__Login(struct soap *soap, _ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__Login * SOAP_FMAC2 soap_instantiate__ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__Login, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__Login);
		if (size)
			*size = sizeof(_ns1__Login);
		((_ns1__Login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__Login, n);
		if (size)
			*size = n * sizeof(_ns1__Login);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__Login*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__Login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__Login %p -> %p\n", q, p));
	*(_ns1__Login*)p = *(_ns1__Login*)q;
}

void _ns1__GetReportStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetReportStateResponse::GetReportStateResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetReportStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, &this->_ns1__GetReportStateResponse::GetReportStateResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetReportStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReportStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReportStateResponse(struct soap *soap, const char *tag, int id, const _ns1__GetReportStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReportStateResponse), type))
		return soap->error;
	if (a->GetReportStateResult)
		soap_element_result(soap, "ns1:GetReportStateResult");
	if (soap_out_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, "ns1:GetReportStateResult", -1, &(a->_ns1__GetReportStateResponse::GetReportStateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReportStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReportStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReportStateResponse * SOAP_FMAC4 soap_in__ns1__GetReportStateResponse(struct soap *soap, const char *tag, _ns1__GetReportStateResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReportStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReportStateResponse, sizeof(_ns1__GetReportStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReportStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReportStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetReportStateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetReportStateResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, "ns1:GetReportStateResult", &(a->_ns1__GetReportStateResponse::GetReportStateResult), ""))
				{	soap_flag_GetReportStateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetReportStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReportStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReportStateResponse, 0, sizeof(_ns1__GetReportStateResponse), 0, soap_copy__ns1__GetReportStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReportStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetReportStateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetReportStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReportStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReportStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReportStateResponse * SOAP_FMAC4 soap_get__ns1__GetReportStateResponse(struct soap *soap, _ns1__GetReportStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReportStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReportStateResponse * SOAP_FMAC2 soap_instantiate__ns1__GetReportStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReportStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReportStateResponse, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetReportStateResponse);
		if (size)
			*size = sizeof(_ns1__GetReportStateResponse);
		((_ns1__GetReportStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetReportStateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetReportStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetReportStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetReportStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReportStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReportStateResponse %p -> %p\n", q, p));
	*(_ns1__GetReportStateResponse*)p = *(_ns1__GetReportStateResponse*)q;
}

void _ns1__GetReportState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetReportState::sFileName);
	/* transient soap skipped */
}

void _ns1__GetReportState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->_ns1__GetReportState::sFileName);
	/* transient soap skipped */
#endif
}

int _ns1__GetReportState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetReportState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetReportState(struct soap *soap, const char *tag, int id, const _ns1__GetReportState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetReportState), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sFileName", -1, &(a->_ns1__GetReportState::sFileName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetReportState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetReportState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetReportState * SOAP_FMAC4 soap_in__ns1__GetReportState(struct soap *soap, const char *tag, _ns1__GetReportState *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetReportState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetReportState, sizeof(_ns1__GetReportState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetReportState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetReportState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sFileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sFileName", &(a->_ns1__GetReportState::sFileName), "xsd:string"))
				{	soap_flag_sFileName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetReportState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetReportState, 0, sizeof(_ns1__GetReportState), 0, soap_copy__ns1__GetReportState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetReportState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE__ns1__GetReportState);
	if (this->soap_out(soap, tag?tag:"ns1:GetReportState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetReportState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetReportState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetReportState * SOAP_FMAC4 soap_get__ns1__GetReportState(struct soap *soap, _ns1__GetReportState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetReportState * SOAP_FMAC2 soap_instantiate__ns1__GetReportState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetReportState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetReportState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(_ns1__GetReportState);
		if (size)
			*size = sizeof(_ns1__GetReportState);
		((_ns1__GetReportState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(_ns1__GetReportState, n);
		if (size)
			*size = n * sizeof(_ns1__GetReportState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetReportState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetReportState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetReportState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetReportState %p -> %p\n", q, p));
	*(_ns1__GetReportState*)p = *(_ns1__GetReportState*)q;
}

void ns1__AuthHeader::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__AuthHeader::authKey);
	this->ns1__AuthHeader::__anyAttribute = NULL;
	/* transient soap skipped */
}

void ns1__AuthHeader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &this->ns1__AuthHeader::authKey);
	/* transient soap skipped */
#endif
}

int ns1__AuthHeader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AuthHeader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthHeader(struct soap *soap, const char *tag, int id, const ns1__AuthHeader *a, const char *type)
{
	if (((ns1__AuthHeader*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((ns1__AuthHeader*)a)->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthHeader), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:authKey", -1, &(a->ns1__AuthHeader::authKey), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AuthHeader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AuthHeader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AuthHeader * SOAP_FMAC4 soap_in_ns1__AuthHeader(struct soap *soap, const char *tag, ns1__AuthHeader *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AuthHeader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthHeader, sizeof(ns1__AuthHeader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AuthHeader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AuthHeader *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((ns1__AuthHeader*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag_authKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:authKey", &(a->ns1__AuthHeader::authKey), "xsd:string"))
				{	soap_flag_authKey1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AuthHeader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthHeader, 0, sizeof(ns1__AuthHeader), 0, soap_copy_ns1__AuthHeader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__AuthHeader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, NULL, 0, SOAP_TYPE_ns1__AuthHeader);
	if (this->soap_out(soap, tag?tag:"ns1:AuthHeader", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AuthHeader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AuthHeader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AuthHeader * SOAP_FMAC4 soap_get_ns1__AuthHeader(struct soap *soap, ns1__AuthHeader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AuthHeader * SOAP_FMAC2 soap_instantiate_ns1__AuthHeader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthHeader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthHeader, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(ns1__AuthHeader);
		if (size)
			*size = sizeof(ns1__AuthHeader);
		((ns1__AuthHeader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(ns1__AuthHeader, n);
		if (size)
			*size = n * sizeof(ns1__AuthHeader);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__AuthHeader*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__AuthHeader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthHeader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AuthHeader %p -> %p\n", q, p));
	*(ns1__AuthHeader*)p = *(ns1__AuthHeader*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)(void*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)(void*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int id = soap_embed(soap, (void*)this, (struct soap_array*)(void*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateQuery_(struct soap *soap, struct __ns1__UpdateQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateQuery_(struct soap *soap, const struct __ns1__UpdateQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateQuery(soap, &a->ns1__UpdateQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateQuery_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateQuery(soap, "ns1:UpdateQuery", -1, &a->ns1__UpdateQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateQuery_ * SOAP_FMAC4 soap_in___ns1__UpdateQuery_(struct soap *soap, const char *tag, struct __ns1__UpdateQuery_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdateQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateQuery_, sizeof(struct __ns1__UpdateQuery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateQuery(soap, "ns1:UpdateQuery", &a->ns1__UpdateQuery, ""))
				{	soap_flag_ns1__UpdateQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateQuery_(struct soap *soap, const struct __ns1__UpdateQuery_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdateQuery_(soap, tag?tag:"-ns1:UpdateQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateQuery_ * SOAP_FMAC4 soap_get___ns1__UpdateQuery_(struct soap *soap, struct __ns1__UpdateQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateQuery_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateQuery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateQuery_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdateQuery_);
		if (size)
			*size = sizeof(struct __ns1__UpdateQuery_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdateQuery_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateQuery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateQuery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateQuery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateQuery_ %p -> %p\n", q, p));
	*(struct __ns1__UpdateQuery_*)p = *(struct __ns1__UpdateQuery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetQuery_(struct soap *soap, struct __ns1__GetQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetQuery_(struct soap *soap, const struct __ns1__GetQuery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetQuery(soap, &a->ns1__GetQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetQuery_(struct soap *soap, const char *tag, int id, const struct __ns1__GetQuery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetQuery(soap, "ns1:GetQuery", -1, &a->ns1__GetQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetQuery_ * SOAP_FMAC4 soap_in___ns1__GetQuery_(struct soap *soap, const char *tag, struct __ns1__GetQuery_ *a, const char *type)
{
	size_t soap_flag_ns1__GetQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetQuery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetQuery_, sizeof(struct __ns1__GetQuery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetQuery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetQuery(soap, "ns1:GetQuery", &a->ns1__GetQuery, ""))
				{	soap_flag_ns1__GetQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetQuery_(struct soap *soap, const struct __ns1__GetQuery_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__GetQuery_(soap, tag?tag:"-ns1:GetQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetQuery_ * SOAP_FMAC4 soap_get___ns1__GetQuery_(struct soap *soap, struct __ns1__GetQuery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetQuery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetQuery_ * SOAP_FMAC2 soap_instantiate___ns1__GetQuery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetQuery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetQuery_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__GetQuery_);
		if (size)
			*size = sizeof(struct __ns1__GetQuery_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__GetQuery_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetQuery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetQuery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetQuery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetQuery_ %p -> %p\n", q, p));
	*(struct __ns1__GetQuery_*)p = *(struct __ns1__GetQuery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadFile_(struct soap *soap, struct __ns1__UploadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadFile_(struct soap *soap, const struct __ns1__UploadFile_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadFile(soap, &a->ns1__UploadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadFile_(struct soap *soap, const char *tag, int id, const struct __ns1__UploadFile_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadFile(soap, "ns1:UploadFile", -1, &a->ns1__UploadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadFile_ * SOAP_FMAC4 soap_in___ns1__UploadFile_(struct soap *soap, const char *tag, struct __ns1__UploadFile_ *a, const char *type)
{
	size_t soap_flag_ns1__UploadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadFile_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadFile_, sizeof(struct __ns1__UploadFile_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadFile_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadFile(soap, "ns1:UploadFile", &a->ns1__UploadFile, ""))
				{	soap_flag_ns1__UploadFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadFile_(struct soap *soap, const struct __ns1__UploadFile_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UploadFile_(soap, tag?tag:"-ns1:UploadFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadFile_ * SOAP_FMAC4 soap_get___ns1__UploadFile_(struct soap *soap, struct __ns1__UploadFile_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadFile_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadFile_ * SOAP_FMAC2 soap_instantiate___ns1__UploadFile_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadFile_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadFile_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UploadFile_);
		if (size)
			*size = sizeof(struct __ns1__UploadFile_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UploadFile_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadFile_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadFile_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadFile_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadFile_ %p -> %p\n", q, p));
	*(struct __ns1__UploadFile_*)p = *(struct __ns1__UploadFile_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncReportState_(struct soap *soap, struct __ns1__SyncReportState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncReportState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncReportState_(struct soap *soap, const struct __ns1__SyncReportState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncReportState(soap, &a->ns1__SyncReportState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncReportState_(struct soap *soap, const char *tag, int id, const struct __ns1__SyncReportState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncReportState(soap, "ns1:SyncReportState", -1, &a->ns1__SyncReportState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncReportState_ * SOAP_FMAC4 soap_in___ns1__SyncReportState_(struct soap *soap, const char *tag, struct __ns1__SyncReportState_ *a, const char *type)
{
	size_t soap_flag_ns1__SyncReportState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncReportState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncReportState_, sizeof(struct __ns1__SyncReportState_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncReportState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncReportState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncReportState(soap, "ns1:SyncReportState", &a->ns1__SyncReportState, ""))
				{	soap_flag_ns1__SyncReportState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncReportState_(struct soap *soap, const struct __ns1__SyncReportState_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncReportState_(soap, tag?tag:"-ns1:SyncReportState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncReportState_ * SOAP_FMAC4 soap_get___ns1__SyncReportState_(struct soap *soap, struct __ns1__SyncReportState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncReportState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncReportState_ * SOAP_FMAC2 soap_instantiate___ns1__SyncReportState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncReportState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncReportState_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncReportState_);
		if (size)
			*size = sizeof(struct __ns1__SyncReportState_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncReportState_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncReportState_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncReportState_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncReportState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncReportState_ %p -> %p\n", q, p));
	*(struct __ns1__SyncReportState_*)p = *(struct __ns1__SyncReportState_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataState_(struct soap *soap, struct __ns1__UpdateDataState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDataState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataState_(struct soap *soap, const struct __ns1__UpdateDataState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateDataState(soap, &a->ns1__UpdateDataState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataState_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateDataState(soap, "ns1:UpdateDataState", -1, &a->ns1__UpdateDataState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataState_ * SOAP_FMAC4 soap_in___ns1__UpdateDataState_(struct soap *soap, const char *tag, struct __ns1__UpdateDataState_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDataState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateDataState_, sizeof(struct __ns1__UpdateDataState_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDataState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDataState(soap, "ns1:UpdateDataState", &a->ns1__UpdateDataState, ""))
				{	soap_flag_ns1__UpdateDataState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataState_(struct soap *soap, const struct __ns1__UpdateDataState_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdateDataState_(soap, tag?tag:"-ns1:UpdateDataState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataState_ * SOAP_FMAC4 soap_get___ns1__UpdateDataState_(struct soap *soap, struct __ns1__UpdateDataState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateDataState_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateDataState_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdateDataState_);
		if (size)
			*size = sizeof(struct __ns1__UpdateDataState_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdateDataState_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateDataState_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateDataState_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateDataState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateDataState_ %p -> %p\n", q, p));
	*(struct __ns1__UpdateDataState_*)p = *(struct __ns1__UpdateDataState_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncDataState_(struct soap *soap, struct __ns1__SyncDataState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncDataState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncDataState_(struct soap *soap, const struct __ns1__SyncDataState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncDataState(soap, &a->ns1__SyncDataState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncDataState_(struct soap *soap, const char *tag, int id, const struct __ns1__SyncDataState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncDataState(soap, "ns1:SyncDataState", -1, &a->ns1__SyncDataState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncDataState_ * SOAP_FMAC4 soap_in___ns1__SyncDataState_(struct soap *soap, const char *tag, struct __ns1__SyncDataState_ *a, const char *type)
{
	size_t soap_flag_ns1__SyncDataState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncDataState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncDataState_, sizeof(struct __ns1__SyncDataState_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncDataState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncDataState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncDataState(soap, "ns1:SyncDataState", &a->ns1__SyncDataState, ""))
				{	soap_flag_ns1__SyncDataState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncDataState_(struct soap *soap, const struct __ns1__SyncDataState_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncDataState_(soap, tag?tag:"-ns1:SyncDataState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncDataState_ * SOAP_FMAC4 soap_get___ns1__SyncDataState_(struct soap *soap, struct __ns1__SyncDataState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncDataState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncDataState_ * SOAP_FMAC2 soap_instantiate___ns1__SyncDataState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncDataState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncDataState_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncDataState_);
		if (size)
			*size = sizeof(struct __ns1__SyncDataState_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncDataState_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncDataState_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncDataState_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncDataState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncDataState_ %p -> %p\n", q, p));
	*(struct __ns1__SyncDataState_*)p = *(struct __ns1__SyncDataState_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdatePatientInfo_(struct soap *soap, struct __ns1__UpdatePatientInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePatientInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdatePatientInfo_(struct soap *soap, const struct __ns1__UpdatePatientInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdatePatientInfo(soap, &a->ns1__UpdatePatientInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdatePatientInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdatePatientInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdatePatientInfo(soap, "ns1:UpdatePatientInfo", -1, &a->ns1__UpdatePatientInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePatientInfo_ * SOAP_FMAC4 soap_in___ns1__UpdatePatientInfo_(struct soap *soap, const char *tag, struct __ns1__UpdatePatientInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePatientInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdatePatientInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdatePatientInfo_, sizeof(struct __ns1__UpdatePatientInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdatePatientInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePatientInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePatientInfo(soap, "ns1:UpdatePatientInfo", &a->ns1__UpdatePatientInfo, ""))
				{	soap_flag_ns1__UpdatePatientInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdatePatientInfo_(struct soap *soap, const struct __ns1__UpdatePatientInfo_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdatePatientInfo_(soap, tag?tag:"-ns1:UpdatePatientInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePatientInfo_ * SOAP_FMAC4 soap_get___ns1__UpdatePatientInfo_(struct soap *soap, struct __ns1__UpdatePatientInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdatePatientInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdatePatientInfo_ * SOAP_FMAC2 soap_instantiate___ns1__UpdatePatientInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdatePatientInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdatePatientInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdatePatientInfo_);
		if (size)
			*size = sizeof(struct __ns1__UpdatePatientInfo_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdatePatientInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdatePatientInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdatePatientInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdatePatientInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdatePatientInfo_ %p -> %p\n", q, p));
	*(struct __ns1__UpdatePatientInfo_*)p = *(struct __ns1__UpdatePatientInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncPatientInfo_(struct soap *soap, struct __ns1__SyncPatientInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncPatientInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncPatientInfo_(struct soap *soap, const struct __ns1__SyncPatientInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncPatientInfo(soap, &a->ns1__SyncPatientInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncPatientInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__SyncPatientInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncPatientInfo(soap, "ns1:SyncPatientInfo", -1, &a->ns1__SyncPatientInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncPatientInfo_ * SOAP_FMAC4 soap_in___ns1__SyncPatientInfo_(struct soap *soap, const char *tag, struct __ns1__SyncPatientInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__SyncPatientInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncPatientInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncPatientInfo_, sizeof(struct __ns1__SyncPatientInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncPatientInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncPatientInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncPatientInfo(soap, "ns1:SyncPatientInfo", &a->ns1__SyncPatientInfo, ""))
				{	soap_flag_ns1__SyncPatientInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncPatientInfo_(struct soap *soap, const struct __ns1__SyncPatientInfo_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncPatientInfo_(soap, tag?tag:"-ns1:SyncPatientInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncPatientInfo_ * SOAP_FMAC4 soap_get___ns1__SyncPatientInfo_(struct soap *soap, struct __ns1__SyncPatientInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncPatientInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncPatientInfo_ * SOAP_FMAC2 soap_instantiate___ns1__SyncPatientInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncPatientInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncPatientInfo_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncPatientInfo_);
		if (size)
			*size = sizeof(struct __ns1__SyncPatientInfo_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncPatientInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncPatientInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncPatientInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncPatientInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncPatientInfo_ %p -> %p\n", q, p));
	*(struct __ns1__SyncPatientInfo_*)p = *(struct __ns1__SyncPatientInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login_(struct soap *soap, struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login_(struct soap *soap, const char *tag, int id, const struct __ns1__Login_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_in___ns1__Login_(struct soap *soap, const char *tag, struct __ns1__Login_ *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login_, sizeof(struct __ns1__Login_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login_(struct soap *soap, const struct __ns1__Login_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__Login_(soap, tag?tag:"-ns1:Login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login_ * SOAP_FMAC4 soap_get___ns1__Login_(struct soap *soap, struct __ns1__Login_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Login_ * SOAP_FMAC2 soap_instantiate___ns1__Login_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Login_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__Login_);
		if (size)
			*size = sizeof(struct __ns1__Login_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__Login_, n);
		if (size)
			*size = n * sizeof(struct __ns1__Login_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Login_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Login_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Login_ %p -> %p\n", q, p));
	*(struct __ns1__Login_*)p = *(struct __ns1__Login_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetReportState_(struct soap *soap, struct __ns1__GetReportState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReportState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetReportState_(struct soap *soap, const struct __ns1__GetReportState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetReportState(soap, &a->ns1__GetReportState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetReportState_(struct soap *soap, const char *tag, int id, const struct __ns1__GetReportState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetReportState(soap, "ns1:GetReportState", -1, &a->ns1__GetReportState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetReportState_ * SOAP_FMAC4 soap_in___ns1__GetReportState_(struct soap *soap, const char *tag, struct __ns1__GetReportState_ *a, const char *type)
{
	size_t soap_flag_ns1__GetReportState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetReportState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetReportState_, sizeof(struct __ns1__GetReportState_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetReportState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReportState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReportState(soap, "ns1:GetReportState", &a->ns1__GetReportState, ""))
				{	soap_flag_ns1__GetReportState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetReportState_(struct soap *soap, const struct __ns1__GetReportState_ *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__GetReportState_(soap, tag?tag:"-ns1:GetReportState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetReportState_ * SOAP_FMAC4 soap_get___ns1__GetReportState_(struct soap *soap, struct __ns1__GetReportState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetReportState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetReportState_ * SOAP_FMAC2 soap_instantiate___ns1__GetReportState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetReportState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetReportState_, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__GetReportState_);
		if (size)
			*size = sizeof(struct __ns1__GetReportState_);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__GetReportState_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetReportState_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetReportState_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetReportState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetReportState_ %p -> %p\n", q, p));
	*(struct __ns1__GetReportState_*)p = *(struct __ns1__GetReportState_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateQuery(struct soap *soap, struct __ns1__UpdateQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateQuery(struct soap *soap, const struct __ns1__UpdateQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateQuery(soap, &a->ns1__UpdateQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateQuery(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateQuery(soap, "ns1:UpdateQuery", -1, &a->ns1__UpdateQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateQuery * SOAP_FMAC4 soap_in___ns1__UpdateQuery(struct soap *soap, const char *tag, struct __ns1__UpdateQuery *a, const char *type)
{
	size_t soap_flag_ns1__UpdateQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateQuery, sizeof(struct __ns1__UpdateQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateQuery(soap, "ns1:UpdateQuery", &a->ns1__UpdateQuery, ""))
				{	soap_flag_ns1__UpdateQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateQuery(struct soap *soap, const struct __ns1__UpdateQuery *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdateQuery(soap, tag?tag:"-ns1:UpdateQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateQuery * SOAP_FMAC4 soap_get___ns1__UpdateQuery(struct soap *soap, struct __ns1__UpdateQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateQuery * SOAP_FMAC2 soap_instantiate___ns1__UpdateQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateQuery, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdateQuery);
		if (size)
			*size = sizeof(struct __ns1__UpdateQuery);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdateQuery, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateQuery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateQuery %p -> %p\n", q, p));
	*(struct __ns1__UpdateQuery*)p = *(struct __ns1__UpdateQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetQuery(struct soap *soap, struct __ns1__GetQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetQuery(struct soap *soap, const struct __ns1__GetQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetQuery(soap, &a->ns1__GetQuery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetQuery(struct soap *soap, const char *tag, int id, const struct __ns1__GetQuery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetQuery(soap, "ns1:GetQuery", -1, &a->ns1__GetQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetQuery * SOAP_FMAC4 soap_in___ns1__GetQuery(struct soap *soap, const char *tag, struct __ns1__GetQuery *a, const char *type)
{
	size_t soap_flag_ns1__GetQuery = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetQuery, sizeof(struct __ns1__GetQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetQuery(soap, "ns1:GetQuery", &a->ns1__GetQuery, ""))
				{	soap_flag_ns1__GetQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetQuery(struct soap *soap, const struct __ns1__GetQuery *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__GetQuery(soap, tag?tag:"-ns1:GetQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetQuery * SOAP_FMAC4 soap_get___ns1__GetQuery(struct soap *soap, struct __ns1__GetQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetQuery * SOAP_FMAC2 soap_instantiate___ns1__GetQuery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetQuery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetQuery, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__GetQuery);
		if (size)
			*size = sizeof(struct __ns1__GetQuery);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__GetQuery, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetQuery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetQuery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetQuery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetQuery %p -> %p\n", q, p));
	*(struct __ns1__GetQuery*)p = *(struct __ns1__GetQuery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UploadFile(struct soap *soap, struct __ns1__UploadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UploadFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UploadFile(struct soap *soap, const struct __ns1__UploadFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UploadFile(soap, &a->ns1__UploadFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UploadFile(struct soap *soap, const char *tag, int id, const struct __ns1__UploadFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UploadFile(soap, "ns1:UploadFile", -1, &a->ns1__UploadFile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadFile * SOAP_FMAC4 soap_in___ns1__UploadFile(struct soap *soap, const char *tag, struct __ns1__UploadFile *a, const char *type)
{
	size_t soap_flag_ns1__UploadFile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UploadFile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UploadFile, sizeof(struct __ns1__UploadFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UploadFile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UploadFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UploadFile(soap, "ns1:UploadFile", &a->ns1__UploadFile, ""))
				{	soap_flag_ns1__UploadFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UploadFile(struct soap *soap, const struct __ns1__UploadFile *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UploadFile(soap, tag?tag:"-ns1:UploadFile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UploadFile * SOAP_FMAC4 soap_get___ns1__UploadFile(struct soap *soap, struct __ns1__UploadFile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UploadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UploadFile * SOAP_FMAC2 soap_instantiate___ns1__UploadFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UploadFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UploadFile, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UploadFile);
		if (size)
			*size = sizeof(struct __ns1__UploadFile);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UploadFile, n);
		if (size)
			*size = n * sizeof(struct __ns1__UploadFile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UploadFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UploadFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UploadFile %p -> %p\n", q, p));
	*(struct __ns1__UploadFile*)p = *(struct __ns1__UploadFile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncReportState(struct soap *soap, struct __ns1__SyncReportState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncReportState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncReportState(struct soap *soap, const struct __ns1__SyncReportState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncReportState(soap, &a->ns1__SyncReportState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncReportState(struct soap *soap, const char *tag, int id, const struct __ns1__SyncReportState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncReportState(soap, "ns1:SyncReportState", -1, &a->ns1__SyncReportState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncReportState * SOAP_FMAC4 soap_in___ns1__SyncReportState(struct soap *soap, const char *tag, struct __ns1__SyncReportState *a, const char *type)
{
	size_t soap_flag_ns1__SyncReportState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncReportState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncReportState, sizeof(struct __ns1__SyncReportState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncReportState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncReportState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncReportState(soap, "ns1:SyncReportState", &a->ns1__SyncReportState, ""))
				{	soap_flag_ns1__SyncReportState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncReportState(struct soap *soap, const struct __ns1__SyncReportState *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncReportState(soap, tag?tag:"-ns1:SyncReportState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncReportState * SOAP_FMAC4 soap_get___ns1__SyncReportState(struct soap *soap, struct __ns1__SyncReportState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncReportState * SOAP_FMAC2 soap_instantiate___ns1__SyncReportState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncReportState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncReportState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncReportState);
		if (size)
			*size = sizeof(struct __ns1__SyncReportState);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncReportState, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncReportState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncReportState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncReportState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncReportState %p -> %p\n", q, p));
	*(struct __ns1__SyncReportState*)p = *(struct __ns1__SyncReportState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateDataState(struct soap *soap, struct __ns1__UpdateDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateDataState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateDataState(struct soap *soap, const struct __ns1__UpdateDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdateDataState(soap, &a->ns1__UpdateDataState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateDataState(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdateDataState(soap, "ns1:UpdateDataState", -1, &a->ns1__UpdateDataState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataState * SOAP_FMAC4 soap_in___ns1__UpdateDataState(struct soap *soap, const char *tag, struct __ns1__UpdateDataState *a, const char *type)
{
	size_t soap_flag_ns1__UpdateDataState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdateDataState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateDataState, sizeof(struct __ns1__UpdateDataState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateDataState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateDataState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateDataState(soap, "ns1:UpdateDataState", &a->ns1__UpdateDataState, ""))
				{	soap_flag_ns1__UpdateDataState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateDataState(struct soap *soap, const struct __ns1__UpdateDataState *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdateDataState(soap, tag?tag:"-ns1:UpdateDataState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateDataState * SOAP_FMAC4 soap_get___ns1__UpdateDataState(struct soap *soap, struct __ns1__UpdateDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateDataState * SOAP_FMAC2 soap_instantiate___ns1__UpdateDataState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateDataState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateDataState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdateDataState);
		if (size)
			*size = sizeof(struct __ns1__UpdateDataState);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdateDataState, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateDataState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateDataState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateDataState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateDataState %p -> %p\n", q, p));
	*(struct __ns1__UpdateDataState*)p = *(struct __ns1__UpdateDataState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncDataState(struct soap *soap, struct __ns1__SyncDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncDataState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncDataState(struct soap *soap, const struct __ns1__SyncDataState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncDataState(soap, &a->ns1__SyncDataState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncDataState(struct soap *soap, const char *tag, int id, const struct __ns1__SyncDataState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncDataState(soap, "ns1:SyncDataState", -1, &a->ns1__SyncDataState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncDataState * SOAP_FMAC4 soap_in___ns1__SyncDataState(struct soap *soap, const char *tag, struct __ns1__SyncDataState *a, const char *type)
{
	size_t soap_flag_ns1__SyncDataState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncDataState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncDataState, sizeof(struct __ns1__SyncDataState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncDataState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncDataState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncDataState(soap, "ns1:SyncDataState", &a->ns1__SyncDataState, ""))
				{	soap_flag_ns1__SyncDataState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncDataState(struct soap *soap, const struct __ns1__SyncDataState *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncDataState(soap, tag?tag:"-ns1:SyncDataState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncDataState * SOAP_FMAC4 soap_get___ns1__SyncDataState(struct soap *soap, struct __ns1__SyncDataState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncDataState * SOAP_FMAC2 soap_instantiate___ns1__SyncDataState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncDataState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncDataState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncDataState);
		if (size)
			*size = sizeof(struct __ns1__SyncDataState);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncDataState, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncDataState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncDataState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncDataState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncDataState %p -> %p\n", q, p));
	*(struct __ns1__SyncDataState*)p = *(struct __ns1__SyncDataState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdatePatientInfo(struct soap *soap, struct __ns1__UpdatePatientInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePatientInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdatePatientInfo(struct soap *soap, const struct __ns1__UpdatePatientInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__UpdatePatientInfo(soap, &a->ns1__UpdatePatientInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdatePatientInfo(struct soap *soap, const char *tag, int id, const struct __ns1__UpdatePatientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__UpdatePatientInfo(soap, "ns1:UpdatePatientInfo", -1, &a->ns1__UpdatePatientInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePatientInfo * SOAP_FMAC4 soap_in___ns1__UpdatePatientInfo(struct soap *soap, const char *tag, struct __ns1__UpdatePatientInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePatientInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__UpdatePatientInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdatePatientInfo, sizeof(struct __ns1__UpdatePatientInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdatePatientInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePatientInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePatientInfo(soap, "ns1:UpdatePatientInfo", &a->ns1__UpdatePatientInfo, ""))
				{	soap_flag_ns1__UpdatePatientInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdatePatientInfo(struct soap *soap, const struct __ns1__UpdatePatientInfo *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__UpdatePatientInfo(soap, tag?tag:"-ns1:UpdatePatientInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePatientInfo * SOAP_FMAC4 soap_get___ns1__UpdatePatientInfo(struct soap *soap, struct __ns1__UpdatePatientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdatePatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdatePatientInfo * SOAP_FMAC2 soap_instantiate___ns1__UpdatePatientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdatePatientInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdatePatientInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__UpdatePatientInfo);
		if (size)
			*size = sizeof(struct __ns1__UpdatePatientInfo);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__UpdatePatientInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdatePatientInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdatePatientInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdatePatientInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdatePatientInfo %p -> %p\n", q, p));
	*(struct __ns1__UpdatePatientInfo*)p = *(struct __ns1__UpdatePatientInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__SyncPatientInfo(struct soap *soap, struct __ns1__SyncPatientInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__SyncPatientInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__SyncPatientInfo(struct soap *soap, const struct __ns1__SyncPatientInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__SyncPatientInfo(soap, &a->ns1__SyncPatientInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__SyncPatientInfo(struct soap *soap, const char *tag, int id, const struct __ns1__SyncPatientInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__SyncPatientInfo(soap, "ns1:SyncPatientInfo", -1, &a->ns1__SyncPatientInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncPatientInfo * SOAP_FMAC4 soap_in___ns1__SyncPatientInfo(struct soap *soap, const char *tag, struct __ns1__SyncPatientInfo *a, const char *type)
{
	size_t soap_flag_ns1__SyncPatientInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__SyncPatientInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__SyncPatientInfo, sizeof(struct __ns1__SyncPatientInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__SyncPatientInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SyncPatientInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__SyncPatientInfo(soap, "ns1:SyncPatientInfo", &a->ns1__SyncPatientInfo, ""))
				{	soap_flag_ns1__SyncPatientInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__SyncPatientInfo(struct soap *soap, const struct __ns1__SyncPatientInfo *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__SyncPatientInfo(soap, tag?tag:"-ns1:SyncPatientInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__SyncPatientInfo * SOAP_FMAC4 soap_get___ns1__SyncPatientInfo(struct soap *soap, struct __ns1__SyncPatientInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__SyncPatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__SyncPatientInfo * SOAP_FMAC2 soap_instantiate___ns1__SyncPatientInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__SyncPatientInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__SyncPatientInfo, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__SyncPatientInfo);
		if (size)
			*size = sizeof(struct __ns1__SyncPatientInfo);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__SyncPatientInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__SyncPatientInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__SyncPatientInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__SyncPatientInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__SyncPatientInfo %p -> %p\n", q, p));
	*(struct __ns1__SyncPatientInfo*)p = *(struct __ns1__SyncPatientInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Login(struct soap *soap, struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Login = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Login(struct soap *soap, const struct __ns1__Login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Login(soap, &a->ns1__Login);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Login(struct soap *soap, const char *tag, int id, const struct __ns1__Login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Login(soap, "ns1:Login", -1, &a->ns1__Login, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_in___ns1__Login(struct soap *soap, const char *tag, struct __ns1__Login *a, const char *type)
{
	size_t soap_flag_ns1__Login = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Login *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Login, sizeof(struct __ns1__Login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Login && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Login(soap, "ns1:Login", &a->ns1__Login, ""))
				{	soap_flag_ns1__Login--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Login(struct soap *soap, const struct __ns1__Login *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__Login(soap, tag?tag:"-ns1:Login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Login * SOAP_FMAC4 soap_get___ns1__Login(struct soap *soap, struct __ns1__Login *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__Login * SOAP_FMAC2 soap_instantiate___ns1__Login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__Login, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__Login);
		if (size)
			*size = sizeof(struct __ns1__Login);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__Login, n);
		if (size)
			*size = n * sizeof(struct __ns1__Login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__Login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__Login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__Login %p -> %p\n", q, p));
	*(struct __ns1__Login*)p = *(struct __ns1__Login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetReportState(struct soap *soap, struct __ns1__GetReportState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetReportState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetReportState(struct soap *soap, const struct __ns1__GetReportState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetReportState(soap, &a->ns1__GetReportState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetReportState(struct soap *soap, const char *tag, int id, const struct __ns1__GetReportState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetReportState(soap, "ns1:GetReportState", -1, &a->ns1__GetReportState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetReportState * SOAP_FMAC4 soap_in___ns1__GetReportState(struct soap *soap, const char *tag, struct __ns1__GetReportState *a, const char *type)
{
	size_t soap_flag_ns1__GetReportState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetReportState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetReportState, sizeof(struct __ns1__GetReportState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetReportState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetReportState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetReportState(soap, "ns1:GetReportState", &a->ns1__GetReportState, ""))
				{	soap_flag_ns1__GetReportState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetReportState(struct soap *soap, const struct __ns1__GetReportState *a, const char *tag, const char *type)
{
	int id = 0;
	if (soap_out___ns1__GetReportState(soap, tag?tag:"-ns1:GetReportState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetReportState * SOAP_FMAC4 soap_get___ns1__GetReportState(struct soap *soap, struct __ns1__GetReportState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetReportState * SOAP_FMAC2 soap_instantiate___ns1__GetReportState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetReportState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetReportState, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct __ns1__GetReportState);
		if (size)
			*size = sizeof(struct __ns1__GetReportState);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct __ns1__GetReportState, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetReportState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetReportState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetReportState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetReportState %p -> %p\n", q, p));
	*(struct __ns1__GetReportState*)p = *(struct __ns1__GetReportState*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__AuthHeader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AuthHeader(soap, &a->ns1__AuthHeader_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTons1__AuthHeader(soap, "ns1:AuthHeader", -1, &a->ns1__AuthHeader_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_ns1__AuthHeader_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__AuthHeader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuthHeader(soap, "ns1:AuthHeader", &a->ns1__AuthHeader_, "ns1:AuthHeader"))
				{	soap_flag_ns1__AuthHeader_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateQuery(struct soap *soap, _ns1__UpdateQuery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateQuery(struct soap *soap, const char *tag, int id, _ns1__UpdateQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateQuery ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateQuery(struct soap *soap, const char *tag, _ns1__UpdateQuery **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateQuery **)soap_malloc(soap, sizeof(_ns1__UpdateQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateQuery *)soap_instantiate__ns1__UpdateQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateQuery ** p = (_ns1__UpdateQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateQuery, sizeof(_ns1__UpdateQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateQuery(struct soap *soap, _ns1__UpdateQuery *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UpdateQuery);
	if (soap_out_PointerTo_ns1__UpdateQuery(soap, tag?tag:"ns1:UpdateQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateQuery ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateQuery(struct soap *soap, _ns1__UpdateQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetQuery(struct soap *soap, _ns1__GetQuery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetQuery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetQuery(struct soap *soap, const char *tag, int id, _ns1__GetQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetQuery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetQuery ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetQuery(struct soap *soap, const char *tag, _ns1__GetQuery **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetQuery **)soap_malloc(soap, sizeof(_ns1__GetQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetQuery *)soap_instantiate__ns1__GetQuery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetQuery ** p = (_ns1__GetQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetQuery, sizeof(_ns1__GetQuery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetQuery(struct soap *soap, _ns1__GetQuery *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetQuery);
	if (soap_out_PointerTo_ns1__GetQuery(soap, tag?tag:"ns1:GetQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetQuery ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetQuery(struct soap *soap, _ns1__GetQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UploadFile(struct soap *soap, _ns1__UploadFile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UploadFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UploadFile(struct soap *soap, const char *tag, int id, _ns1__UploadFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UploadFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UploadFile ** SOAP_FMAC4 soap_in_PointerTo_ns1__UploadFile(struct soap *soap, const char *tag, _ns1__UploadFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UploadFile **)soap_malloc(soap, sizeof(_ns1__UploadFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UploadFile *)soap_instantiate__ns1__UploadFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UploadFile ** p = (_ns1__UploadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UploadFile, sizeof(_ns1__UploadFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UploadFile(struct soap *soap, _ns1__UploadFile *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UploadFile);
	if (soap_out_PointerTo_ns1__UploadFile(soap, tag?tag:"ns1:UploadFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UploadFile ** SOAP_FMAC4 soap_get_PointerTo_ns1__UploadFile(struct soap *soap, _ns1__UploadFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UploadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SyncReportState(struct soap *soap, _ns1__SyncReportState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SyncReportState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SyncReportState(struct soap *soap, const char *tag, int id, _ns1__SyncReportState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SyncReportState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SyncReportState ** SOAP_FMAC4 soap_in_PointerTo_ns1__SyncReportState(struct soap *soap, const char *tag, _ns1__SyncReportState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SyncReportState **)soap_malloc(soap, sizeof(_ns1__SyncReportState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SyncReportState *)soap_instantiate__ns1__SyncReportState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SyncReportState ** p = (_ns1__SyncReportState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SyncReportState, sizeof(_ns1__SyncReportState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SyncReportState(struct soap *soap, _ns1__SyncReportState *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__SyncReportState);
	if (soap_out_PointerTo_ns1__SyncReportState(soap, tag?tag:"ns1:SyncReportState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SyncReportState ** SOAP_FMAC4 soap_get_PointerTo_ns1__SyncReportState(struct soap *soap, _ns1__SyncReportState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SyncReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateDataState(struct soap *soap, _ns1__UpdateDataState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateDataState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateDataState(struct soap *soap, const char *tag, int id, _ns1__UpdateDataState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateDataState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateDataState ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateDataState(struct soap *soap, const char *tag, _ns1__UpdateDataState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateDataState **)soap_malloc(soap, sizeof(_ns1__UpdateDataState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateDataState *)soap_instantiate__ns1__UpdateDataState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateDataState ** p = (_ns1__UpdateDataState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateDataState, sizeof(_ns1__UpdateDataState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateDataState(struct soap *soap, _ns1__UpdateDataState *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UpdateDataState);
	if (soap_out_PointerTo_ns1__UpdateDataState(soap, tag?tag:"ns1:UpdateDataState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateDataState ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateDataState(struct soap *soap, _ns1__UpdateDataState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SyncDataState(struct soap *soap, _ns1__SyncDataState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SyncDataState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SyncDataState(struct soap *soap, const char *tag, int id, _ns1__SyncDataState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SyncDataState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SyncDataState ** SOAP_FMAC4 soap_in_PointerTo_ns1__SyncDataState(struct soap *soap, const char *tag, _ns1__SyncDataState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SyncDataState **)soap_malloc(soap, sizeof(_ns1__SyncDataState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SyncDataState *)soap_instantiate__ns1__SyncDataState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SyncDataState ** p = (_ns1__SyncDataState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SyncDataState, sizeof(_ns1__SyncDataState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SyncDataState(struct soap *soap, _ns1__SyncDataState *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__SyncDataState);
	if (soap_out_PointerTo_ns1__SyncDataState(soap, tag?tag:"ns1:SyncDataState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SyncDataState ** SOAP_FMAC4 soap_get_PointerTo_ns1__SyncDataState(struct soap *soap, _ns1__SyncDataState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SyncDataState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePatientInfo(struct soap *soap, _ns1__UpdatePatientInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePatientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePatientInfo(struct soap *soap, const char *tag, int id, _ns1__UpdatePatientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePatientInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePatientInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePatientInfo(struct soap *soap, const char *tag, _ns1__UpdatePatientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePatientInfo **)soap_malloc(soap, sizeof(_ns1__UpdatePatientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePatientInfo *)soap_instantiate__ns1__UpdatePatientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatePatientInfo ** p = (_ns1__UpdatePatientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePatientInfo, sizeof(_ns1__UpdatePatientInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePatientInfo(struct soap *soap, _ns1__UpdatePatientInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__UpdatePatientInfo);
	if (soap_out_PointerTo_ns1__UpdatePatientInfo(soap, tag?tag:"ns1:UpdatePatientInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePatientInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePatientInfo(struct soap *soap, _ns1__UpdatePatientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__SyncPatientInfo(struct soap *soap, _ns1__SyncPatientInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__SyncPatientInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__SyncPatientInfo(struct soap *soap, const char *tag, int id, _ns1__SyncPatientInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__SyncPatientInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__SyncPatientInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__SyncPatientInfo(struct soap *soap, const char *tag, _ns1__SyncPatientInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__SyncPatientInfo **)soap_malloc(soap, sizeof(_ns1__SyncPatientInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__SyncPatientInfo *)soap_instantiate__ns1__SyncPatientInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__SyncPatientInfo ** p = (_ns1__SyncPatientInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__SyncPatientInfo, sizeof(_ns1__SyncPatientInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__SyncPatientInfo(struct soap *soap, _ns1__SyncPatientInfo *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__SyncPatientInfo);
	if (soap_out_PointerTo_ns1__SyncPatientInfo(soap, tag?tag:"ns1:SyncPatientInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__SyncPatientInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__SyncPatientInfo(struct soap *soap, _ns1__SyncPatientInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__SyncPatientInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Login))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Login(struct soap *soap, const char *tag, int id, _ns1__Login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_in_PointerTo_ns1__Login(struct soap *soap, const char *tag, _ns1__Login **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Login **)soap_malloc(soap, sizeof(_ns1__Login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Login *)soap_instantiate__ns1__Login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__Login ** p = (_ns1__Login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Login, sizeof(_ns1__Login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Login(struct soap *soap, _ns1__Login *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__Login);
	if (soap_out_PointerTo_ns1__Login(soap, tag?tag:"ns1:Login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Login ** SOAP_FMAC4 soap_get_PointerTo_ns1__Login(struct soap *soap, _ns1__Login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReportState(struct soap *soap, _ns1__GetReportState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReportState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReportState(struct soap *soap, const char *tag, int id, _ns1__GetReportState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReportState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReportState ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReportState(struct soap *soap, const char *tag, _ns1__GetReportState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReportState **)soap_malloc(soap, sizeof(_ns1__GetReportState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReportState *)soap_instantiate__ns1__GetReportState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReportState ** p = (_ns1__GetReportState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReportState, sizeof(_ns1__GetReportState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReportState(struct soap *soap, _ns1__GetReportState *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetReportState);
	if (soap_out_PointerTo_ns1__GetReportState(soap, tag?tag:"ns1:GetReportState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReportState ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReportState(struct soap *soap, _ns1__GetReportState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReportState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuthHeader(struct soap *soap, ns1__AuthHeader *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AuthHeader))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuthHeader(struct soap *soap, const char *tag, int id, ns1__AuthHeader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuthHeader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AuthHeader ** SOAP_FMAC4 soap_in_PointerTons1__AuthHeader(struct soap *soap, const char *tag, ns1__AuthHeader **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AuthHeader **)soap_malloc(soap, sizeof(ns1__AuthHeader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AuthHeader *)soap_instantiate_ns1__AuthHeader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AuthHeader ** p = (ns1__AuthHeader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthHeader, sizeof(ns1__AuthHeader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuthHeader(struct soap *soap, ns1__AuthHeader *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTons1__AuthHeader);
	if (soap_out_PointerTons1__AuthHeader(soap, tag?tag:"ns1:AuthHeader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AuthHeader ** SOAP_FMAC4 soap_get_PointerTons1__AuthHeader(struct soap *soap, ns1__AuthHeader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuthHeader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetQueryResponse_GetQueryResult(struct soap *soap, _ns1__GetQueryResponse_GetQueryResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetQueryResponse_GetQueryResult(struct soap *soap, const char *tag, int id, _ns1__GetQueryResponse_GetQueryResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetQueryResponse_GetQueryResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetQueryResponse_GetQueryResult(struct soap *soap, const char *tag, _ns1__GetQueryResponse_GetQueryResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetQueryResponse_GetQueryResult **)soap_malloc(soap, sizeof(_ns1__GetQueryResponse_GetQueryResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetQueryResponse_GetQueryResult *)soap_instantiate__ns1__GetQueryResponse_GetQueryResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetQueryResponse_GetQueryResult ** p = (_ns1__GetQueryResponse_GetQueryResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetQueryResponse_GetQueryResult, sizeof(_ns1__GetQueryResponse_GetQueryResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetQueryResponse_GetQueryResult(struct soap *soap, _ns1__GetQueryResponse_GetQueryResult *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetQueryResponse_GetQueryResult);
	if (soap_out_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, tag?tag:"ns1:GetQueryResponse-GetQueryResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetQueryResponse_GetQueryResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetQueryResponse_GetQueryResult(struct soap *soap, _ns1__GetQueryResponse_GetQueryResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetQueryResponse_GetQueryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)(void*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, _ns1__GetReportStateResponse_GetReportStateResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, const char *tag, int id, _ns1__GetReportStateResponse_GetReportStateResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetReportStateResponse_GetReportStateResult ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, const char *tag, _ns1__GetReportStateResponse_GetReportStateResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetReportStateResponse_GetReportStateResult **)soap_malloc(soap, sizeof(_ns1__GetReportStateResponse_GetReportStateResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetReportStateResponse_GetReportStateResult *)soap_instantiate__ns1__GetReportStateResponse_GetReportStateResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetReportStateResponse_GetReportStateResult ** p = (_ns1__GetReportStateResponse_GetReportStateResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetReportStateResponse_GetReportStateResult, sizeof(_ns1__GetReportStateResponse_GetReportStateResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, _ns1__GetReportStateResponse_GetReportStateResult *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTo_ns1__GetReportStateResponse_GetReportStateResult);
	if (soap_out_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, tag?tag:"ns1:GetReportStateResponse-GetReportStateResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetReportStateResponse_GetReportStateResult ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(struct soap *soap, _ns1__GetReportStateResponse_GetReportStateResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetReportStateResponse_GetReportStateResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	int id = soap_embed(soap, (void*)a, NULL, 0, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
