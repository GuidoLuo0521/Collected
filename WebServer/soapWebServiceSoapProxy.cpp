/* soapWebServiceSoapProxy.cpp
   Generated by gSOAP 2.8.23 from clientservice.h

Copyright(C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/



#include "..\StdAfx.h"
#include "soapWebServiceSoapProxy.h"

WebServiceSoapProxy::WebServiceSoapProxy() : soap(SOAP_IO_DEFAULT)
{	WebServiceSoapProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

WebServiceSoapProxy::WebServiceSoapProxy(const struct soap &_soap) : soap(_soap)
{ }

WebServiceSoapProxy::WebServiceSoapProxy(const char *url) : soap(SOAP_IO_DEFAULT)
{	WebServiceSoapProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
	soap_endpoint = url;
}

WebServiceSoapProxy::WebServiceSoapProxy(soap_mode iomode) : soap(iomode)
{	WebServiceSoapProxy_init(iomode, iomode);
}

WebServiceSoapProxy::WebServiceSoapProxy(const char *url, soap_mode iomode) : soap(iomode)
{	WebServiceSoapProxy_init(iomode, iomode);
	soap_endpoint = url;
}

WebServiceSoapProxy::WebServiceSoapProxy(soap_mode imode, soap_mode omode) : soap(imode, omode)
{	WebServiceSoapProxy_init(imode, omode);
}

WebServiceSoapProxy::~WebServiceSoapProxy()
{
	this->destroy();
	}

void WebServiceSoapProxy::WebServiceSoapProxy_init(soap_mode imode, soap_mode omode)
{	soap_imode(this, imode);
	soap_omode(this, omode);
	soap_endpoint = NULL;
	static const struct Namespace namespaces[] =
{
	{"SOAP-ENV", "http://www.w3.org/2003/05/soap-envelope", "http://schemas.xmlsoap.org/soap/envelope/", NULL},
	{"SOAP-ENC", "http://www.w3.org/2003/05/soap-encoding", "http://schemas.xmlsoap.org/soap/encoding/", NULL},
	{"xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL},
	{"xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL},
	{"ns1", "http://StaticECG.koanruler.com/", NULL, NULL},
	{NULL, NULL, NULL, NULL}
};
	soap_set_namespaces(this, namespaces);
}

void WebServiceSoapProxy::destroy()
{	soap_destroy(this);
	soap_end(this);
}

void WebServiceSoapProxy::reset()
{	this->destroy();
	soap_done(this);
	soap_initialize(this);
	WebServiceSoapProxy_init(SOAP_IO_DEFAULT, SOAP_IO_DEFAULT);
}

void WebServiceSoapProxy::soap_noheader()
{	this->header = NULL;
}

void WebServiceSoapProxy::soap_header(ns1__AuthHeader *ns1__AuthHeader_)
{	::soap_header(this);
	this->header->ns1__AuthHeader_ = ns1__AuthHeader_;
}

const SOAP_ENV__Header *WebServiceSoapProxy::soap_header()
{	return this->header;
}

const SOAP_ENV__Fault *WebServiceSoapProxy::soap_fault()
{	return this->fault;
}

const char *WebServiceSoapProxy::soap_fault_string()
{	return *soap_faultstring(this);
}

const char *WebServiceSoapProxy::soap_fault_detail()
{	return *soap_faultdetail(this);
}

int WebServiceSoapProxy::soap_close_socket()
{	return soap_closesock(this);
}

int WebServiceSoapProxy::soap_force_close_socket()
{	return soap_force_closesock(this);
}

void WebServiceSoapProxy::soap_print_fault(FILE *fd)
{	::soap_print_fault(this, fd);
}

#ifndef WITH_LEAN
#ifndef WITH_COMPAT
void WebServiceSoapProxy::soap_stream_fault(std::ostream& os)
{	::soap_stream_fault(this, os);
}
#endif

char *WebServiceSoapProxy::soap_sprint_fault(char *buf, size_t len)
{	return ::soap_sprint_fault(this, buf, len);
}
#endif

int WebServiceSoapProxy::GetReportState(const char *endpoint, const char *soap_action, _ns1__GetReportState *ns1__GetReportState, _ns1__GetReportStateResponse &ns1__GetReportStateResponse)
{	struct soap *soap = this;
	struct __ns1__GetReportState soap_tmp___ns1__GetReportState;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/GetReportState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__GetReportState.ns1__GetReportState = ns1__GetReportState;
	soap_serializeheader(soap);
	soap_serialize___ns1__GetReportState(soap, &soap_tmp___ns1__GetReportState);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__GetReportState(soap, &soap_tmp___ns1__GetReportState, "-ns1:GetReportState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__GetReportState(soap, &soap_tmp___ns1__GetReportState, "-ns1:GetReportState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__GetReportStateResponse)
		return soap_closesock(soap);
	ns1__GetReportStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__GetReportStateResponse.soap_get(soap, "ns1:GetReportStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::Login(const char *endpoint, const char *soap_action, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse)
{	struct soap *soap = this;
	struct __ns1__Login soap_tmp___ns1__Login;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/Login";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__Login.ns1__Login = ns1__Login;
	soap_serializeheader(soap);
	soap_serialize___ns1__Login(soap, &soap_tmp___ns1__Login);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__Login(soap, &soap_tmp___ns1__Login, "-ns1:Login", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__Login(soap, &soap_tmp___ns1__Login, "-ns1:Login", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__LoginResponse)
		return soap_closesock(soap);
	ns1__LoginResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__LoginResponse.soap_get(soap, "ns1:LoginResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncPatientInfo(const char *endpoint, const char *soap_action, _ns1__SyncPatientInfo *ns1__SyncPatientInfo, _ns1__SyncPatientInfoResponse &ns1__SyncPatientInfoResponse)
{	struct soap *soap = this;
	struct __ns1__SyncPatientInfo soap_tmp___ns1__SyncPatientInfo;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncPatientInfo";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncPatientInfo.ns1__SyncPatientInfo = ns1__SyncPatientInfo;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncPatientInfo(soap, &soap_tmp___ns1__SyncPatientInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncPatientInfo(soap, &soap_tmp___ns1__SyncPatientInfo, "-ns1:SyncPatientInfo", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncPatientInfo(soap, &soap_tmp___ns1__SyncPatientInfo, "-ns1:SyncPatientInfo", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncPatientInfoResponse)
		return soap_closesock(soap);
	ns1__SyncPatientInfoResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncPatientInfoResponse.soap_get(soap, "ns1:SyncPatientInfoResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdatePatientInfo(const char *endpoint, const char *soap_action, _ns1__UpdatePatientInfo *ns1__UpdatePatientInfo, _ns1__UpdatePatientInfoResponse &ns1__UpdatePatientInfoResponse)
{	struct soap *soap = this;
	struct __ns1__UpdatePatientInfo soap_tmp___ns1__UpdatePatientInfo;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdatePatientInfo";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdatePatientInfo.ns1__UpdatePatientInfo = ns1__UpdatePatientInfo;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdatePatientInfo(soap, &soap_tmp___ns1__UpdatePatientInfo);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdatePatientInfo(soap, &soap_tmp___ns1__UpdatePatientInfo, "-ns1:UpdatePatientInfo", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdatePatientInfo(soap, &soap_tmp___ns1__UpdatePatientInfo, "-ns1:UpdatePatientInfo", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdatePatientInfoResponse)
		return soap_closesock(soap);
	ns1__UpdatePatientInfoResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdatePatientInfoResponse.soap_get(soap, "ns1:UpdatePatientInfoResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncDataState(const char *endpoint, const char *soap_action, _ns1__SyncDataState *ns1__SyncDataState, _ns1__SyncDataStateResponse &ns1__SyncDataStateResponse)
{	struct soap *soap = this;
	struct __ns1__SyncDataState soap_tmp___ns1__SyncDataState;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncDataState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncDataState.ns1__SyncDataState = ns1__SyncDataState;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncDataState(soap, &soap_tmp___ns1__SyncDataState);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncDataState(soap, &soap_tmp___ns1__SyncDataState, "-ns1:SyncDataState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncDataState(soap, &soap_tmp___ns1__SyncDataState, "-ns1:SyncDataState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncDataStateResponse)
		return soap_closesock(soap);
	ns1__SyncDataStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncDataStateResponse.soap_get(soap, "ns1:SyncDataStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdateDataState(const char *endpoint, const char *soap_action, _ns1__UpdateDataState *ns1__UpdateDataState, _ns1__UpdateDataStateResponse &ns1__UpdateDataStateResponse)
{	struct soap *soap = this;
	struct __ns1__UpdateDataState soap_tmp___ns1__UpdateDataState;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdateDataState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdateDataState.ns1__UpdateDataState = ns1__UpdateDataState;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdateDataState(soap, &soap_tmp___ns1__UpdateDataState);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdateDataState(soap, &soap_tmp___ns1__UpdateDataState, "-ns1:UpdateDataState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdateDataState(soap, &soap_tmp___ns1__UpdateDataState, "-ns1:UpdateDataState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdateDataStateResponse)
		return soap_closesock(soap);
	ns1__UpdateDataStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdateDataStateResponse.soap_get(soap, "ns1:UpdateDataStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncReportState(const char *endpoint, const char *soap_action, _ns1__SyncReportState *ns1__SyncReportState, _ns1__SyncReportStateResponse &ns1__SyncReportStateResponse)
{	struct soap *soap = this;
	struct __ns1__SyncReportState soap_tmp___ns1__SyncReportState;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncReportState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncReportState.ns1__SyncReportState = ns1__SyncReportState;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncReportState(soap, &soap_tmp___ns1__SyncReportState);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncReportState(soap, &soap_tmp___ns1__SyncReportState, "-ns1:SyncReportState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncReportState(soap, &soap_tmp___ns1__SyncReportState, "-ns1:SyncReportState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncReportStateResponse)
		return soap_closesock(soap);
	ns1__SyncReportStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncReportStateResponse.soap_get(soap, "ns1:SyncReportStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UploadFile(const char *endpoint, const char *soap_action, _ns1__UploadFile *ns1__UploadFile, _ns1__UploadFileResponse &ns1__UploadFileResponse)
{	struct soap *soap = this;
	struct __ns1__UploadFile soap_tmp___ns1__UploadFile;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UploadFile";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UploadFile.ns1__UploadFile = ns1__UploadFile;
	soap_serializeheader(soap);
	soap_serialize___ns1__UploadFile(soap, &soap_tmp___ns1__UploadFile);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UploadFile(soap, &soap_tmp___ns1__UploadFile, "-ns1:UploadFile", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UploadFile(soap, &soap_tmp___ns1__UploadFile, "-ns1:UploadFile", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UploadFileResponse)
		return soap_closesock(soap);
	ns1__UploadFileResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UploadFileResponse.soap_get(soap, "ns1:UploadFileResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::GetQuery(const char *endpoint, const char *soap_action, _ns1__GetQuery *ns1__GetQuery, _ns1__GetQueryResponse &ns1__GetQueryResponse)
{	struct soap *soap = this;
	struct __ns1__GetQuery soap_tmp___ns1__GetQuery;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/GetQuery";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__GetQuery.ns1__GetQuery = ns1__GetQuery;
	soap_serializeheader(soap);
	soap_serialize___ns1__GetQuery(soap, &soap_tmp___ns1__GetQuery);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__GetQuery(soap, &soap_tmp___ns1__GetQuery, "-ns1:GetQuery", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__GetQuery(soap, &soap_tmp___ns1__GetQuery, "-ns1:GetQuery", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__GetQueryResponse)
		return soap_closesock(soap);
	ns1__GetQueryResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__GetQueryResponse.soap_get(soap, "ns1:GetQueryResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdateQuery(const char *endpoint, const char *soap_action, _ns1__UpdateQuery *ns1__UpdateQuery, _ns1__UpdateQueryResponse &ns1__UpdateQueryResponse)
{	struct soap *soap = this;
	struct __ns1__UpdateQuery soap_tmp___ns1__UpdateQuery;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdateQuery";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdateQuery.ns1__UpdateQuery = ns1__UpdateQuery;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdateQuery(soap, &soap_tmp___ns1__UpdateQuery);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdateQuery(soap, &soap_tmp___ns1__UpdateQuery, "-ns1:UpdateQuery", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdateQuery(soap, &soap_tmp___ns1__UpdateQuery, "-ns1:UpdateQuery", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdateQueryResponse)
		return soap_closesock(soap);
	ns1__UpdateQueryResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdateQueryResponse.soap_get(soap, "ns1:UpdateQueryResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::GetReportState_(const char *endpoint, const char *soap_action, _ns1__GetReportState *ns1__GetReportState, _ns1__GetReportStateResponse &ns1__GetReportStateResponse)
{	struct soap *soap = this;
	struct __ns1__GetReportState_ soap_tmp___ns1__GetReportState_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/GetReportState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__GetReportState_.ns1__GetReportState = ns1__GetReportState;
	soap_serializeheader(soap);
	soap_serialize___ns1__GetReportState_(soap, &soap_tmp___ns1__GetReportState_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__GetReportState_(soap, &soap_tmp___ns1__GetReportState_, "-ns1:GetReportState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__GetReportState_(soap, &soap_tmp___ns1__GetReportState_, "-ns1:GetReportState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__GetReportStateResponse)
		return soap_closesock(soap);
	ns1__GetReportStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__GetReportStateResponse.soap_get(soap, "ns1:GetReportStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::Login_(const char *endpoint, const char *soap_action, _ns1__Login *ns1__Login, _ns1__LoginResponse &ns1__LoginResponse)
{	struct soap *soap = this;
	struct __ns1__Login_ soap_tmp___ns1__Login_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/Login";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__Login_.ns1__Login = ns1__Login;
	soap_serializeheader(soap);
	soap_serialize___ns1__Login_(soap, &soap_tmp___ns1__Login_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__Login_(soap, &soap_tmp___ns1__Login_, "-ns1:Login", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__Login_(soap, &soap_tmp___ns1__Login_, "-ns1:Login", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__LoginResponse)
		return soap_closesock(soap);
	ns1__LoginResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__LoginResponse.soap_get(soap, "ns1:LoginResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncPatientInfo_(const char *endpoint, const char *soap_action, _ns1__SyncPatientInfo *ns1__SyncPatientInfo, _ns1__SyncPatientInfoResponse &ns1__SyncPatientInfoResponse)
{	struct soap *soap = this;
	struct __ns1__SyncPatientInfo_ soap_tmp___ns1__SyncPatientInfo_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncPatientInfo";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncPatientInfo_.ns1__SyncPatientInfo = ns1__SyncPatientInfo;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncPatientInfo_(soap, &soap_tmp___ns1__SyncPatientInfo_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncPatientInfo_(soap, &soap_tmp___ns1__SyncPatientInfo_, "-ns1:SyncPatientInfo", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncPatientInfo_(soap, &soap_tmp___ns1__SyncPatientInfo_, "-ns1:SyncPatientInfo", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncPatientInfoResponse)
		return soap_closesock(soap);
	ns1__SyncPatientInfoResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncPatientInfoResponse.soap_get(soap, "ns1:SyncPatientInfoResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdatePatientInfo_(const char *endpoint, const char *soap_action, _ns1__UpdatePatientInfo *ns1__UpdatePatientInfo, _ns1__UpdatePatientInfoResponse &ns1__UpdatePatientInfoResponse)
{	struct soap *soap = this;
	struct __ns1__UpdatePatientInfo_ soap_tmp___ns1__UpdatePatientInfo_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdatePatientInfo";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdatePatientInfo_.ns1__UpdatePatientInfo = ns1__UpdatePatientInfo;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdatePatientInfo_(soap, &soap_tmp___ns1__UpdatePatientInfo_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdatePatientInfo_(soap, &soap_tmp___ns1__UpdatePatientInfo_, "-ns1:UpdatePatientInfo", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdatePatientInfo_(soap, &soap_tmp___ns1__UpdatePatientInfo_, "-ns1:UpdatePatientInfo", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdatePatientInfoResponse)
		return soap_closesock(soap);
	ns1__UpdatePatientInfoResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdatePatientInfoResponse.soap_get(soap, "ns1:UpdatePatientInfoResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncDataState_(const char *endpoint, const char *soap_action, _ns1__SyncDataState *ns1__SyncDataState, _ns1__SyncDataStateResponse &ns1__SyncDataStateResponse)
{	struct soap *soap = this;
	struct __ns1__SyncDataState_ soap_tmp___ns1__SyncDataState_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncDataState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncDataState_.ns1__SyncDataState = ns1__SyncDataState;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncDataState_(soap, &soap_tmp___ns1__SyncDataState_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncDataState_(soap, &soap_tmp___ns1__SyncDataState_, "-ns1:SyncDataState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncDataState_(soap, &soap_tmp___ns1__SyncDataState_, "-ns1:SyncDataState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncDataStateResponse)
		return soap_closesock(soap);
	ns1__SyncDataStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncDataStateResponse.soap_get(soap, "ns1:SyncDataStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdateDataState_(const char *endpoint, const char *soap_action, _ns1__UpdateDataState *ns1__UpdateDataState, _ns1__UpdateDataStateResponse &ns1__UpdateDataStateResponse)
{	struct soap *soap = this;
	struct __ns1__UpdateDataState_ soap_tmp___ns1__UpdateDataState_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdateDataState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdateDataState_.ns1__UpdateDataState = ns1__UpdateDataState;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdateDataState_(soap, &soap_tmp___ns1__UpdateDataState_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdateDataState_(soap, &soap_tmp___ns1__UpdateDataState_, "-ns1:UpdateDataState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdateDataState_(soap, &soap_tmp___ns1__UpdateDataState_, "-ns1:UpdateDataState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdateDataStateResponse)
		return soap_closesock(soap);
	ns1__UpdateDataStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdateDataStateResponse.soap_get(soap, "ns1:UpdateDataStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::SyncReportState_(const char *endpoint, const char *soap_action, _ns1__SyncReportState *ns1__SyncReportState, _ns1__SyncReportStateResponse &ns1__SyncReportStateResponse)
{	struct soap *soap = this;
	struct __ns1__SyncReportState_ soap_tmp___ns1__SyncReportState_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/SyncReportState";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__SyncReportState_.ns1__SyncReportState = ns1__SyncReportState;
	soap_serializeheader(soap);
	soap_serialize___ns1__SyncReportState_(soap, &soap_tmp___ns1__SyncReportState_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__SyncReportState_(soap, &soap_tmp___ns1__SyncReportState_, "-ns1:SyncReportState", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__SyncReportState_(soap, &soap_tmp___ns1__SyncReportState_, "-ns1:SyncReportState", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__SyncReportStateResponse)
		return soap_closesock(soap);
	ns1__SyncReportStateResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__SyncReportStateResponse.soap_get(soap, "ns1:SyncReportStateResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UploadFile_(const char *endpoint, const char *soap_action, _ns1__UploadFile *ns1__UploadFile, _ns1__UploadFileResponse &ns1__UploadFileResponse)
{	struct soap *soap = this;
	struct __ns1__UploadFile_ soap_tmp___ns1__UploadFile_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UploadFile";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UploadFile_.ns1__UploadFile = ns1__UploadFile;
	soap_serializeheader(soap);
	soap_serialize___ns1__UploadFile_(soap, &soap_tmp___ns1__UploadFile_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UploadFile_(soap, &soap_tmp___ns1__UploadFile_, "-ns1:UploadFile", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UploadFile_(soap, &soap_tmp___ns1__UploadFile_, "-ns1:UploadFile", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UploadFileResponse)
		return soap_closesock(soap);
	ns1__UploadFileResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UploadFileResponse.soap_get(soap, "ns1:UploadFileResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::GetQuery_(const char *endpoint, const char *soap_action, _ns1__GetQuery *ns1__GetQuery, _ns1__GetQueryResponse &ns1__GetQueryResponse)
{	struct soap *soap = this;
	struct __ns1__GetQuery_ soap_tmp___ns1__GetQuery_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/GetQuery";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__GetQuery_.ns1__GetQuery = ns1__GetQuery;
	soap_serializeheader(soap);
	soap_serialize___ns1__GetQuery_(soap, &soap_tmp___ns1__GetQuery_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__GetQuery_(soap, &soap_tmp___ns1__GetQuery_, "-ns1:GetQuery", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__GetQuery_(soap, &soap_tmp___ns1__GetQuery_, "-ns1:GetQuery", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__GetQueryResponse)
		return soap_closesock(soap);
	ns1__GetQueryResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__GetQueryResponse.soap_get(soap, "ns1:GetQueryResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}

int WebServiceSoapProxy::UpdateQuery_(const char *endpoint, const char *soap_action, _ns1__UpdateQuery *ns1__UpdateQuery, _ns1__UpdateQueryResponse &ns1__UpdateQueryResponse)
{	struct soap *soap = this;
	struct __ns1__UpdateQuery_ soap_tmp___ns1__UpdateQuery_;
	if (endpoint)
		soap_endpoint = endpoint;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://ecg.koanruler.com:2081/StaticECGWebSite/WebService.asmx";
	if (soap_action == NULL)
		soap_action = "http://StaticECG.koanruler.com/UpdateQuery";
	soap_begin(soap);
	soap->encodingStyle = NULL;
	soap_tmp___ns1__UpdateQuery_.ns1__UpdateQuery = ns1__UpdateQuery;
	soap_serializeheader(soap);
	soap_serialize___ns1__UpdateQuery_(soap, &soap_tmp___ns1__UpdateQuery_);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put___ns1__UpdateQuery_(soap, &soap_tmp___ns1__UpdateQuery_, "-ns1:UpdateQuery", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put___ns1__UpdateQuery_(soap, &soap_tmp___ns1__UpdateQuery_, "-ns1:UpdateQuery", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!&ns1__UpdateQueryResponse)
		return soap_closesock(soap);
	ns1__UpdateQueryResponse.soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	ns1__UpdateQueryResponse.soap_get(soap, "ns1:UpdateQueryResponse", NULL);
	if (soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	return soap_closesock(soap);
}
/* End of client proxy code */
